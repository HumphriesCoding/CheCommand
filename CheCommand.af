~~ {
~~ FOR AUTO-COMPLETION ASSISTANCE: testvar getvar setvar touchvar clearallvars clearvar getcharintprop getchardoubleprop getcharquadprop getcharboolprop getcharstringprop getisspellknown getcancastspell_hunt getcancastspell_buff getcharvital_base getcharvital_current getcharvital_buffedmax getcharskill_traininglevel getcharskill_base getcharskill_buffed getplayerlandcell getplayercoordinates coordinategetns coordinategetwe coordinategetz coordinatetostring coordinateparse coordinatedistancewithz coordinatedistanceflat wobjectgetphysicscoordinates wobjectgetname wobjectgetobjectclass wobjectgettemplatetype wobjectgetisdooropen wobjectfindnearestmonster wobjectfindnearestdoor wobjectfindnearestbyobjectclass wobjectfindininventorybytemplatetype wobjectfindininventorybyname wobjectfindininventorybynamerx wobjectgetselection wobjectgetplayer wobjectfindnearestbynameandobjectclass actiontryselect actiontryuseitem actiontryapplyitem actiontrygiveitem actiontryequipanywand actiontrycastbyid actiontrycastbyidontarget chatbox chatboxpaste statushud statushudcolored uigetcontrol uisetlabel isfalse istrue iif randint cstr strlen getobjectinternaltype cstrf stopwatchcreate stopwatchstart stopwatchstop stopwatchelapsedseconds cnumber floor ceiling round abs getworldname getitemcountininventorybyname getheading getitemcountininventorybynamerx getheadingto actiontrygiveprofile vitae getfellowshipstatus getfellowshipname getfellowshipisopen getfellowshipisleader getfellowshipleaderid getfellowshipcanrecruit getfellowid getfellowshipcount getfellowshiplocked getfellowname getfellowshipisfull sin cos tan sqrt asin acos atan atan2 sinh cosh tanh vtsetmetastate getregexmatch echo chr ord wobjectgetid wobjectgethealth wobjectfindbyid wobjectgetintprop wobjectfindnearestbytemplatetype wobjectgetopencontainer testquestflag getquestktprogress isrefreshingquests getquestktrequired getqueststatus getisday getgamehour getgamehourname getisnight getgameday getgameticks getminutesuntilday getgamemonth getgamemonthname getminutesuntilnight getgameyear uisetvisible uiviewvisible uiviewexists getgvar touchgvar getpvar touchpvar setgvar cleargvar setpvar clearpvar testgvar clearallgvars testpvar clearallpvars dictgetitem dictcreate dicthaskey dictadditem dictkeys dictremovekey dictvalues dictclear dictsize dictcopy listgetitem listpop listcreate listcontains listremove listadd listindexof listremoveat listinsert listlastindexof listclear listcopy listcount listreverse

~~																						
~~ File auto-generated by metaf, a program created by Eskarina of Morningthaw/Coldeve.	
~~		Get metaf here: https://github.com/JJEII/metaf/									
~~																						
~~ All recognized structural designators:												
~~		STATE:				DO:															
~~		IF:					NAV:														
~~																						
~~ All recognized CONDITION (IF:) operation keywords:									
~~		Never				NavEmpty			MobsInDist_Priority		Not				
~~		Always				Death				NeedToBuff				PSecsInStateGE	
~~		All					VendorOpen			NoMobsInDist			SecsOnSpellGE	
~~		Any					VendorClosed		BlockE					BuPercentGE		
~~		ChatMatch			ItemCountLE			CellE					DistToRteGE		
~~		MainSlotsLE			ItemCountGE			IntoPortal				Expr			
~~		SecsInStateGE		MobsInDist_Name		ExitPortal				ChatCapture		
~~																						
~~ All recognized ACTION (DO:) operation keywords:										
~~		None				EmbedNav			ChatExpr				SetOpt			
~~		SetState			CallState			SetWatchdog				CreateView		
~~		Chat				Return				ClearWatchdog			DestroyView		
~~		DoAll				DoExpr				GetOpt					DestroyAllViews	
~~																						
~~ All recognized NAV types:															
~~		circular			follow														
~~		linear				once														
~~																						
~~ All recognized NAV NODE types:														
~~		flw					vnd															
~~		pnt					ptl															
~~		rcl					tlk															
~~		pau					chk															
~~		cht					jmp															
~~		prt (deprecated in VTank)														
~~ }																					


STATE: {Default} ~~ {

	~~ Utility Belt Options
	IF: Always
		DO: DoAll
				Chat {/ub opt set VTank.PatchExpressionEngine true}
				Chat {/ub opt set Jumper.ThinkComplete true}
				Chat {/ub opt set Jumper.ThinkFail true}
				Chat {/ub opt set AutoVendor.Think true}

	~~ Constants
	IF: Always
		DO: DoAll

				DoExpr {setvar[NUMBER, 1]}
				DoExpr {setvar[MONSTER, 5]}
				DoExpr {setvar[OBJECT, 7]}
				DoExpr {setvar[PORTAL, 14]}
				DoExpr {setvar[PLAYER, 24]}
				DoExpr {setvar[VENDOR, 25]}
				DoExpr {setvar[CORPSE, 27]}
				DoExpr {setvar[NPC, 37]}

				DoExpr {setvar[SRING_PROP_NAME, 1]}

				DoExpr {setvar[COLOR_DEBUG, 17]}
				DoExpr {setvar[COLOR_INFO, 5]}
				DoExpr {setvar[COLOR_WARN, 31]}
				DoExpr {setvar[COLOR_ERROR, 21]}

				DoExpr {setvar[LEVEL_DEBUG, 10]}
				DoExpr {setvar[LEVEL_INFO, 20]}
				DoExpr {setvar[LEVEL_WARN, 30]}
				DoExpr {setvar[LEVEL_ERROR, 40]}

				DoExpr {setvar[TYPE_NONE, 0]}
				DoExpr {setvar[TYPE_NUMBER, 1]}
				DoExpr {setvar[TYPE_STRING, 3]}
				DoExpr {setvar[TYPE_OBJECT, 7]}

				DoExpr {setvar[CLOSE_BLUE, 7]}

				DoExpr {setvar[CHARACTER_NAME, getcharstringprop[1]]}

	~~ Initialize CC variables
	IF: Always
		DO: DoAll
				DoExpr {setvar[CCVersion, `0.1.0`]}

				DoExpr {setpvar[CCDebug, ifthen[testpvar[CCDebug], `@CCDebug`, `$LEVEL_DEBUG`]]}
				DoExpr {setpvar[CCConfirm, ifthen[testpvar[CCConfirm], `@CCConfirm`, `true`]]}
				DoExpr {setpvar[CCFellowname, ifthen[testpvar[CCFellowname], `@CCFellowname`, `Not Set`]]}
				DoExpr {setpvar[CCCharacterList, ifthen[testpvar[CCCharacterList], `@CCCharacterList`, `listcreate[]`]]}

				~~ Amount of seconds between checking stuck
				DoExpr {setpvar[CCStuckAnnounceDelay, ifthen[testpvar[CCStuckAnnounceDelay], `@CCStuckAnnounceDelay`, `5`]]}

				~~ Maximum amount a character can move to determine stuck
				DoExpr {setpvar[CCStuckThreshold, ifthen[testpvar[CCStuckThreshold], `@CCStuckThreshold`, `1`]]}

				~~ Distance away a character must be to announce stuck
				DoExpr {setpvar[CCStuckDistanceThreshold, ifthen[testpvar[CCStuckDistanceThreshold], `@CCStuckDistanceThreshold`, `20`]]}

				~~ Leader to announce things to. Defaults to first character in @CCCharacterList and will update when follow commands are issued
				DoExpr {setpvar[CCLeader, ifthen[testpvar[CCLeader], `@CCLeader`, `listgetitem[@CCCharacterList, 0]`]]}

				DoExpr {setvar[AutoTimers, listcreate[]]}
				DoExpr {listadd[$AutoTimers, listcreate[11, 00, 00, `AM`, listcreate[`CheCommandNavRecomp`, `CheCommandNavChair`]]]}

				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 20, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 21, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 22, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 23, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 24, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 25, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 26, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 27, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 28, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 29, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}


	~~ Open Remote view
	IF: Always
		DO:	CreateView {Main} {:CheCommand-Main.xml}

	IF:	Expr {$LEVEL_DEBUG>=@CCDebug}
		DO:	DoExpr {echo[`[DEBUG] Che Command v`+$CCVersion+` by Che de Pa of Sundering`, $COLOR_DEBUG]}

	IF: Always
		DO: SetState {Init}
~~ }


STATE: {Init} ~~ {

	~~ If $MetaCallQueue is not a list create it
	IF: Expr {testvar[MetaCallQueue]==0}
		DO: DoExpr {setvar[MetaCallQueue, listcreate[]]}

	~~ Show Debug info about $MetaCallQueue
	IF: Expr {$LEVEL_DEBUG>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[DEBUG] $MetaCallQueue => `+$MetaCallQueue, $COLOR_DEBUG]}

	~~ Clear $MetaCallQueue if reset was used
	IF: Expr {$CCReset==true}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] Reset was called! Clearing queue\`, $COLOR_WARN]`, `false`]}
				DoExpr {listclear[$MetaCallQueue]}
				DoExpr {$CCReset=false}

	~~ Handle calling metas if there's some left in the queue
	IF: Expr {listcount[$MetaCallQueue]>0}
		DO: SetState {CallMeta}

	IF: Always
		DO: DoAll
				DoExpr {setvar[FoundTimers, listcreate[]]}

				DoExpr {setvar[vitals, 1]}

				DoExpr {setvar[CorpseBlacklist, listcreate[]]}
				DoExpr {setvar[StuckTimer, stopwatchstart[stopwatchcreate[]]]}
				DoExpr {$InitialPosition=getplayercoordinates[]}
				DoExpr {$InitialDistance=0}

	IF: Always
		DO: SetState {Idle}

~~ }


STATE: {Idle} ~~ {

	~~ Announce if stuck
	IF: All
			Expr {@CCLeader!=$CHARACTER_NAME}
			Expr {getobjectinternaltype[$leaderObj]==$TYPE_OBJECT} ~~ Leader exists
			Expr {stopwatchelapsedseconds[$StuckTimer]>=@CCStuckAnnounceDelay} ~~ Announce when the $StuckTimer is above the delay
			Expr {coordinatedistancewithz[$InitialPosition, getplayercoordinates[]]<=@CCStuckThreshold} ~~ Character has not moved past the threshold
			Expr {getmotion[Forward]!=0} ~~ Character is moving
			Expr {isportaling[]==false} ~~ Character is not portaling
			Expr {$finalDistance=coordinatedistancewithz[wobjectgetphysicscoordinates[$leaderObj], getplayercoordinates[]]} ~~ Set $finalDistance
			Expr {abs[$finalDistance-$InitialDistance]>=@CCStuckDistanceThreshold} ~~ The distance to the leader is greater than the threshold
			Not Expr {$finalDistance>1000} ~~ The leader hasn't portaled away
		DO: DoAll
				ChatExpr {`/t `+@CCLeader+`, I am stuck and you are `+floor[$finalDistance]+` meters away!`}
				~~ ChatExpr {`/f InitialDistance: `+floor[$finalDistance]}
				~~ ChatExpr {`/f finalDistance: `+floor[$finalDistance]}
				SetState {Idle}

	~~ Restart stuck stopwatch
	IF: All
			Expr {@CCLeader!=$CHARACTER_NAME}
			Expr {stopwatchelapsedseconds[$StuckTimer]>=5}
		DO: DoAll
				DoExpr {$leaderObj=wobjectfindnearestbynameandobjectclass[$PLAYER, @CCLeader]}
				DoExpr {setvar[StuckTimer, stopwatchstart[stopwatchcreate[]]]}
				DoExpr {$InitialDistance=coordinatedistancewithz[wobjectgetphysicscoordinates[$leaderObj], getplayercoordinates[]]}
				DoExpr {$InitialPosition=getplayercoordinates[]}
				SetState {Idle}

	~~ Use VR portal
	IF:	All
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$NPC, `Viridian Portal`]]==$CLOSE_BLUE}
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$NPC, `Viridian Portal`]],getplayercoordinates[]]<15}
		DO:	SetState {VRPortal}

	~~ Handle Auto Timers
	IF: All
			Expr {$FoundTimers=listfilter[$AutoTimers, `cnumber[getdatetimelocal[hh]]==$1{{0}}&&cnumber[getdatetimelocal[mm]]==$1{{1}}&&cnumber[getdatetimelocal[ss]]==$1{{2}}&&getdatetimelocal[tt]==$1{{3}}`]}
			Expr {listcount[$FoundTimers]>0}
		DO: SetState {HandleTimers} 

	~~ Handle Actions
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#action (?<actiontext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleActions}	

	~~ Handle Navigation
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#navto (?<navdestination>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleNavigation}	

	~~ Handle Killtasks
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#killtask (?<ktaction>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleKilltask}	

	~~ Handle Flaggings
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#flag (?<flagaction>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleFlagging}	

	~~ Handle Looting
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#loot (?<loottext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleLooting}	

	~~ Handle Facing a direction
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#face (?<facedirection>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleFace}	

	~~ Handle Jumping text
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#jump (?<jumptext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleJumping}	

	~~ Handle Auto Giving items
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#give\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {AutoGive}	

	~~ Handle Giving items
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#give (?<itemtext>.*) to (?<giveto>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleGive}	

	~~ Handle Checking
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#check (?<checktext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleCheck}

	~~ Handle VTank Options
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#vtoption (?<optiontext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: DoAll
				ChatExpr {`/vt opt set `+$capturegroup_optiontext}
				SetState {Idle}

	~~ Handle Echo
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#echo (?<echotext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: DoAll
				ChatExpr {$capturegroup_echotext}
				SetState {Idle}

	~~ Handle Version
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#version\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
		DO: DoAll
				DoExpr {ifthen[$testvar[capturegroup_name]==true, `chatbox[\`/t \`+$capturegroup_name+\`, CheCommand \`+$CCVersion]`, `chatbox[\`/t \`+$CHARACTER_NAME+\`, CheCommand \`+$CCVersion]`]}
				SetState {Idle}

~~ }


STATE: {HandleTimers} ~~ {

	~~ Return to Idle if no timers found
	IF: Expr {listcount[$FoundTimers]==0}
		DO: SetState {Idle}

	~~ Pop $FoundTimers and CallMeta
	IF: Always
		DO: DoAll
				DoExpr {$timer=listpop[$FoundTimers, 0]}
				DoExpr {$MetaCallQueue=$timer{{4}}}
				SetState {CallMeta}

~~ }

STATE: {CallMeta} ~~ {

	~~ Call a meta with the return meta being CheCommand
	IF: Expr {listcount[$MetaCallQueue]>0}
		DO: DoAll
				DoExpr {$meta=listpop[$MetaCallQueue, 0]}
				DoExpr {$CCReturnMeta=`CheCommand`}
				ChatExpr {`/vt meta load `+$meta}

~~ }


STATE: {HandleActions} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_actiontext]}
		DO: DoAll
				DoExpr {echo[`#action contracts: All characters read contracts in inventory`, $COLOR_INFO]}
				DoExpr {echo[`#action disband: Disbands the fellow`, $COLOR_INFO]}
				DoExpr {echo[`#action fellow: The person issuing the command creates a fellow`, $COLOR_INFO]}
				DoExpr {echo[`#action follow: All characters follow the initiator of the follow command`, $COLOR_INFO]}
				DoExpr {echo[`#action update: All characters reload the meta with the latest changes`, $COLOR_INFO]}
				DoExpr {echo[`#action mule: All characters navigate to Sort de Che and mule`, $COLOR_INFO]}
				DoExpr {echo[`#action npc: All characters use the nearest NPC`, $COLOR_INFO]}
				DoExpr {echo[`#action peace: All characters enter peace mode`, $COLOR_INFO]}
				DoExpr {echo[`#action portal: All characters use the nearest portal`, $COLOR_INFO]}
				DoExpr {echo[`#action quit: All characters exit the game`, $COLOR_INFO]}
				DoExpr {echo[`#action stay: All characters stop following`, $COLOR_INFO]}
				DoExpr {echo[`#action vendor: All characters use the nearest Vendor`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#action stay`
	IF: Expr {(stay)#getvar[capturegroup_actiontext]}	
		DO:	DoAll
				EmbedNav Empty {[None]}
				SetState {Idle}

	~~ Handle `#action follow` for followers
	IF:	All
			Expr {(follow)#getvar[capturegroup_actiontext]}
			Expr {$capturegroup_name!=false}
		DO:	DoAll
				SetOpt {NavPriorityBoost} {true}
				ChatExpr {`/ub follow `+$capturegroup_name}
				DoExpr {@CCLeader=$capturegroup_name}
				SetState {Idle}

	~~ Handle `#action follow` for person who issued command
	IF:	All
			Expr {(follow)#getvar[capturegroup_actiontext]}
			Expr {$capturegroup_name==false}
		DO:	DoAll
				EmbedNav Empty {[None]}
				DoExpr {@CCLeader=$CHARACTER_NAME}
				SetState {Idle}

	~~ Handle `#action fellow` for the person who issued the command
	IF: All
			Expr {(fellow)#getvar[capturegroup_actiontext]}
			Expr {$capturegroup_name==false}
		DO: SetState {CreateFellow}

	~~ Handle `#action fellow` for followers
	IF: All
			Expr {(fellow)#getvar[capturegroup_actiontext]}
			Expr {$capturegroup_name!=false}
		DO: SetState {Idle}

	~~ Handle `#action disband` for leader
	IF: All
			Expr {(disband)#getvar[capturegroup_actiontext]}
			Expr {getfellowshipisleader[]==true}
		DO: DoAll
				ChatExpr {`/ub fellow disband`}
				SetState {Idle}

	~~ Handle `#action disband` for followers
	IF: All
			Expr {(disband)#getvar[capturegroup_actiontext]}
			Expr {getfellowshipisleader[]==false}
		DO: DoAll
				SetState {Idle}

	~~ Handle `#action contracts`
	IF: Expr {(contracts)#getvar[capturegroup_actiontext]}	
		DO:	SetState {ReadContracts}

	~~ Handle `#action update`
	IF: Expr {(update)#getvar[capturegroup_actiontext]}
		DO: Chat {/vt meta load CheCommand}

	~~ Handle `#action mule`
	IF: Expr {(mule)#getvar[capturegroup_actiontext]}
		DO: DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSort`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandHandoffSort`]}
				SetState {CallMeta}

	~~ Handle `#action portal`
	IF: Expr {(portal)#getvar[capturegroup_actiontext]}
		DO: SetState {Portal}

	~~ Handle `#action quit`
	IF: Expr {(quit)#getvar[capturegroup_actiontext]}
		DO: ChatExpr {`/ub quit`}

	~~ Handle `#action npc`
	IF: Expr {(npc)#getvar[capturegroup_actiontext]}
		DO: SetState {UseNPC}

	~~ Handle `#action buff`
	IF: Expr {(buff)#getvar[capturegroup_actiontext]}
		DO: DoAll
				SetOpt {EnableBuffing} {True}
				Chat {/vt forcebuff}
				SetState {Idle}

	~~ Handle `#action peace`
	IF: Expr {(peace)#getvar[capturegroup_actiontext]}
		DO: DoAll
				DoExpr {setcombatstate[peace]}
				SetState {Idle}

	~~ Handle `#action vendor`
	IF: Expr {(vendor)#getvar[capturegroup_actiontext]}
		DO: SetState {UseVendor}

	~~ Handle no match for actiontext
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching action for #action`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleNavigation} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_navdestination]}
		DO: DoAll
				DoExpr {echo[`#navto aphus lassel: Navigate to Aphus Lassel (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto comps: Navigate to Haven and purchase comps`, $COLOR_INFO]}
				DoExpr {echo[`#navto couch: Navigate to Haven and sit on the couch`, $COLOR_INFO]}
				DoExpr {echo[`#navto frozen valley: Navigate to Frozen Valley (requires flagging)`, $COLOR_INFO]}
				DoExpr {echo[`#navto hoshino: Navigate to Hoshino tent (requires flagging)`, $COLOR_INFO]}
				DoExpr {echo[`#navto gear knight: Navigate to Gear Knights (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto graveyard: Navigate to Graveyard (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto neftet: Navigate to Neftet (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto singularity caul: Navigate to Singularity Caul (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto rynthid: Navigate to Rynthid (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto sanctuary: Navigate to Sanctuary (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto secondary: Navigate to Secondary Portal Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto lifestone: Navigate to Lifestone (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto lifestone recall: Navigate to Lifestone Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto primary: Navigate to Primary Portal Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto portal recall: Navigate to Portal Recall (requires spell)`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#navto comps`
	IF: Expr {(comps)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavRecomp`]}
				SetState {CallMeta}

	~~ Handle `#navto couch`
	IF: Expr {(couch)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavChair`]}
				SetState {CallMeta}

	~~ Handle `#navto frozen valley`
	IF: Expr {(frozen valley)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavFrozenValley`]}
				SetState {CallMeta}

	~~ Handle `#navto hoshino`
	IF: Expr {(hoshino)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavHoshino`]}
				SetState {CallMeta}

	~~ Handle `#navto graveyard`
	IF: Expr {(graveyard)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {$CCRecallSpell=4128} ~~ Call of the Mhoire Forge
				SetState {HandleRecall}

	~~ Handle `#navto neftet`
	IF: Expr {(neftet)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavNeftet`]}
				SetState {CallMeta}

	~~ Handle `#navto singularity caul`
	IF: Expr {(singularity caul)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2943} ~~ Recall to the Singularity Caul
				SetState {HandleRecall}

	~~ Handle `#navto rynthid`
	IF: Expr {(rynthid)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=6150} ~~ Rynthid Recall
				SetState {HandleRecall}

	~~ Handle `#navto gearknight`
	IF: Expr {(gear knight)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=5330} ~~ Gear Knight Invasion Area Camp Recall
				SetState {HandleRecall}

	~~ Handle `#navto aphus lassel`
	IF: Expr {(aphus lassel)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2931} ~~ Recall Aphus Lassel
				SetState {HandleRecall}

	~~ Handle `#navto sanctuary`
	IF: Expr {(sanctuary)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2023} ~~ Recall Sanctuary
				SetState {HandleRecall}

	~~ Handle `#navto gear knight`
	IF: Expr {(gear knight)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=5330} ~~ Gear Knight Invasion Area Camp Recall
				SetState {HandleRecall}

	~~ Handle `#navto lifestone`
	IF: Expr {(lifestone)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=1636} ~~ Lifestone Sending
				SetState {HandleRecall}

	~~ Handle `#navto lifestone recall`
	IF: Expr {(lifestone recall)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=1635} ~~ Lifestone recall
				SetState {HandleRecall}

	~~ Handle `#navto portal recall`
	IF: Expr {(portal recall)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2645} ~~ Portal Recall
				SetState {HandleRecall}

	~~ Handle `#navto primary`
	IF: Expr {(primary)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=48} ~~ Primary Portal Recall
				SetState {HandleRecall}

	~~ Handle `#navto secondary`
	IF: Expr {(secondary)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2648} ~~ Secondary Portal Recall
				SetState {HandleRecall}

	~~ Handle no match for navdestination
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching destination for #navto`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleKilltask} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_ktaction]}
		DO: DoAll
				DoExpr {echo[`#killtask check: Checks remaining kill tasks (NOT IMPLEMENTED)`, $COLOR_INFO]}
				DoExpr {echo[`#killtask frozen valley: Begins killtask loop in Frozen Valley`, $COLOR_INFO]}
				DoExpr {echo[`#killtask neftet: Begins killtask loop in Neftet`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#killtask check`
	IF: Expr {(check)#getvar[capturegroup_ktaction]}
		DO: DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskCheck`]}
				SetState {CallMeta}

	~~ Handle `#killtask frozen valley`
	IF: Expr {(frozen valley)#getvar[capturegroup_ktaction]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagFrozenValley`]}
				SetState {CallMeta}

	~~ Handle `#killtask neftet`
	IF: Expr {(neftet)#getvar[capturegroup_ktaction]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagNeftet`]}
				SetState {CallMeta}

	~~ Handle no match for navdestination
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching destination for #killtask`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleFlagging} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_flagaction]}
		DO: DoAll
				DoExpr {echo[`#flag frozen valley: Flags with all NPCs in Frozen Valley`, $COLOR_INFO]}
				DoExpr {echo[`#flag neftet: Flags with all NPCs in Neftet`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#flag frozen valley`
	IF: Expr {(frozen valley)#getvar[capturegroup_flagaction]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagFrozenValley`]}
				SetState {CallMeta}

	~~ Handle `#flag neftet`
	IF: Expr {(neftet)#getvar[capturegroup_flagaction]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagNeftet`]}
				SetState {CallMeta}

	~~ Handle no match for flagaction
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching action for #flag`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleLooting} ~~ {

	IF: Expr {(auto)#getvar[capturegroup_loottext]}	
		DO: SetState {AutoLoot}

	IF: Expr {(test)#getvar[capturegroup_loottext]}	
		DO: SetState {Loot}

~~ }


STATE: {HandleFace} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#check help`
	IF: Expr {(help)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {echo[`#face north`, $COLOR_INFO]}
				DoExpr {echo[`#face south`, $COLOR_INFO]}
				DoExpr {echo[`#face east`, $COLOR_INFO]}
				DoExpr {echo[`#face west`, $COLOR_INFO]}
				DoExpr {echo[`#face northeast`, $COLOR_INFO]}
				DoExpr {echo[`#face northwest`, $COLOR_INFO]}
				DoExpr {echo[`#face southeast`, $COLOR_INFO]}
				DoExpr {echo[`#face southwest`, $COLOR_INFO]}
				DoExpr {echo[`#face <heading>: Face in a specific heading`, $COLOR_INFO]}
				SetState {Idle}

	IF: Expr {(north)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`0`}
				SetState {Face}

	IF: Expr {(south)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`180`}
				SetState {Face}

	IF: Expr {(east)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`90`}
				SetState {Face}

	IF: Expr {(west)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`270`}
				SetState {Face}

	IF: Expr {(northeast)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`45`}
				SetState {Face}

	IF: Expr {(northwest)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`315`}
				SetState {Face}

	IF: Expr {(southeast)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`135`}
				SetState {Face}

	IF: Expr {(southwest)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`225`}
				SetState {Face}

	IF: Always
		DO: DoAll
				DoExpr {$direction=$capturegroup_facedirection}
				SetState {Face}

~~ }


STATE: {Face} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Face}

	IF:	ChatMatch {^You think, "Turning Success"}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, Finished turning\`]`, `false`]}
				DoExpr {clearvar[direction]}
				CallState {EnableOptions} {Idle}

	IF:	ChatMatch {^You think, "Turning failed"}
		DO: SetState {Face}

	IF: Always
		DO: ChatExpr {`/ub face `+$direction}

~~ }


STATE: {HandleJumping} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#jump tap`
	IF: Expr {(tap)#getvar[capturegroup_jumptext]}
		DO: DoAll
				DoExpr {$Jumptext=`sw 250`}
				SetState {Jump}

	~~ Handle `#jump <jumptext>`
	IF: Always
		DO: DoAll
				DoExpr {$Jumptext=$capturegroup_jumptext}
				SetState {Jump}

~~ }


STATE: {Jump} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Jump}

	~~ Try jumping
	IF: Always
		DO: ChatExpr {`/ub jump`+$Jumptext}

	~~ Jump success
	IF:	ChatMatch {^You think, "Jumper Success"}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, Finished jumping\`]`, `false`]}
				CallState {EnableOptions} {Idle}

	~~ Jump failure
	IF:	ChatMatch {^You think, "You have failed to jump too many times}
		DO:	SetState {Jump}

~~ }


STATE: {HandleGive} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Always
		DO: DoAll
				DoExpr {$item=$capturegroup_itemtext}
				DoExpr {$name=$capturegroup_giveto}
				SetState {Give}

~~ }

STATE: {AutoGive} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Always
		DO: DoAll
				DoExpr {setvar[AUTOGIVE_PROFILE, dictcreate[]]}

				~~ Sundering Quests
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Liora Fenn`, `Bitter Tongue's Head`]} ~~ Drudge Hideout Infiltration
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Emissary of Asheron`, listcreate[`Virindi Observer's Message Shard`, `Dark Apostate Shard`, `Engorged Bloodstone Shards`, `Virindi Armorer's Message Shard`, `Dericost Gem of Luminance`]]} ~~ Return to Frore, Empyrean Rescue, 
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Zervakarix`, `Viridian Rise Pocket Watch`]} ~~ Return to Frore

				~~ Legendary Quests
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Uber P`, `Letter from Mouf`]} ~~ Rescuing Mouf P
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mr. P`, `Letter from Mouf and Uber P`]} ~~ Rescuing Mouf P
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kraytuss Nallah`, `Bone Fragment from Shikken Moriyaki`]} ~~ Serpent Burial Grounds
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Collector Golem`, listcreate[`Glowing Statue Shard`, `Essence of the Sundered`]]} ~~ Saving Asheron
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fanzen San the Translator`, listcreate[`Complete Page of Lost Lore`, `Orders for Zrikux`]]} ~~ Lost Lore, Falacot Depot
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Popkin of the Gate`, `The Story of the Lost Sisters`]} ~~ Lost Lore
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Ruby Annex`, `Shroud of Bloodlust`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Amethyst Annex`, `Shroud of Spite`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Jade Annex`, `Shroud of Envy`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Sapphire Annex`, `Shroud of Apathy`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Rinne Gorber`, `Spirit Crystal`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Lady Daenerah`, `Sealed Tome`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mareeno Donn`, `First Lieutenant's Insignia.`]} ~~ Hoshino Infiltration
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fahneph`, `Ancient Falatacot Symbol`]} ~~ Foundry of Izexi
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mhoire Soldier`, `Book`]} ~~ Geraine's Study
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Commander Presk`, `Sealed Scroll for Commander Presk`]} ~~ Lugian Assault
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Raksaa`, `Sealed Scroll for Raksaa`]} ~~ Lugian Assault
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Aun Ol'tra`, `Crimson Scarab`]} ~~ End of Days
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Morgethais`, `Shard of the Curator of Torment's Mask`]} ~~ Defeating the Curator of Torment
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Spirit of Bist'elle`, `Mirror Shard`]} ~~ Hoshino Must Die
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mortified Soldier`, `Torn Note`]} ~~ Gurog Creation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fayza`, `Journal of a Soldier`]} ~~ Gurog Creation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kuyiza bint Zayi the Translator`, listcreate[`Carefully rolled scroll`, `Large Tome`]]} ~~ Bloodstone Investigation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Sir Donovan`, listcreate[`Bloodstone Report`, `Research Notes`, `Shattered Master Bloodstone Shard`, `Delicate Bloodstone Wand`, `Sturdy Bloodstone Wand`]]} ~~ Bloodstone Investigation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Virindi Delegate`, `Olthoi Hive Queen Carapace`]} ~~ Hive Queen Assault

				~~ Luminance Quests
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Aun Aemaua`, `Claw of the Hopeslayer`]} ~~ Ithaenc Quiddity Seed Quest
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Apostate Aetherium Deposit`, `Aetheric Resonator`]} ~~ Nexus Crawl
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Diyas al-Yat`, `Apostate Message Shard`]} ~~ Uncovering the Renegades
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Aruq ibn Balthar`, `Apostate Orders`]} ~~ Uncovering the Renegades
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Neelic`, `Translated Orders for Zrikux`]} ~~ Falacot Depot

				~~ Random
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fiun Rehlyun`, `Insatiable Eater Jaw`]} ~~ Blank Aug Gem
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mana Siphon`, `Unstable Mana Stone`]} ~~ Blank Aug Gem
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kervim'telek`, listcreate[`Essence of Norshuntyr`, `Essence of Night Brier`, `Essence of Wind Fury`, `Essence of Zerzelikyr`]]} ~~ Virindian Rise
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `The Deep`, `Altered Dark Remoran Fin`]} ~~ Society

	~~ No NPC nearby with the Autogive name
	IF: Not Expr {dicthaskey[$AUTOGIVE_PROFILE, wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]]}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, No autogive profile for \`+wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]]`, `false`]}
				SetState {Idle}

	~~ Found NPC hand off to Give
	IF: Expr {dicthaskey[$AUTOGIVE_PROFILE, wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]]}
		DO: DoAll
				DoExpr {$name=wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]}
				DoExpr {$item=dictgetitem[$AUTOGIVE_PROFILE, $name]}
				SetState {Give}

~~ }


STATE: {Give} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Give}

	~~ Successfully handed off item
	IF: Any
			ChatMatch {^You give}
			ChatMatch {^You hand over}
			ChatMatch {^You allow}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, Gave \`+$item]`, `false`]}
				CallState {EnableOptions} {Idle}

	~~ Handle $item being a list
	IF: Expr {getobjectinternaltype[$item]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {$hasItems=listfilter[$item, `wobjectfindininventorybynamerx[\`^\`+$1+\`$\`]`]}
				DoExpr {$item=ifthen[listcount[$hasItems]>=1, `listpop[$hasItems, 0]`, `false`]}
				SetState {Give}

	~~ Missing item
	IF: All
			SecsInStateGE 1
			Expr {wobjectfindininventorybynamerx[`^`+$item+`$`]==false}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, I do not have \`+$item]`, `false`]}
				CallState {EnableOptions} {Idle}

	~~ Give to nearest Player
	IF: All
			Expr {getobjectinternaltype[wobjectfindininventorybynamerx[`^`+$item+`$`]]==$TYPE_OBJECT}
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$PLAYER, $name]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {actiontrygiveitem[wobjectfindininventorybynamerx[`^`+$item+`$`], wobjectfindnearestbynameandobjectclass[$PLAYER, $name]]}
				SetState {Give}

	~~ Give to nearest NPC
	IF: All
			Expr {getobjectinternaltype[wobjectfindininventorybynamerx[`^`+$item+`$`]]==$TYPE_OBJECT}
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$NPC, $name]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {actiontrygiveitem[wobjectfindininventorybynamerx[`^`+$item+`$`], wobjectfindnearestbynameandobjectclass[$NPC, $name]]}
				SetState {Give}

	~~ Handle no player or NPC with that name nearby
	IF: Expr {wobjectfindnearestbynameandobjectclass[$PLAYER, $name]==false&&wobjectfindnearestbynameandobjectclass[$NPC, $name]==false}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, I can't find \`+$name]`, `false`]}
				CallState {EnableOptions} {Idle}

~~ }


STATE: {HandleCheck} ~~ {

	~~ TODO: distance

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#check help`
	IF: Expr {(help)#getvar[capturegroup_checktext]}
		DO: DoAll
				DoExpr {echo[`#check luminance: check how much luminance each character has.`, $COLOR_INFO]}
				DoExpr {echo[`#check level: check what level each character is.`, $COLOR_INFO]}
				DoExpr {echo[`#check landblock: check what landblock each character is in.`, $COLOR_INFO]}
				DoExpr {echo[`#check landcell: check what landcell each character is in.`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#check luminance`
	IF: Expr {(luminance)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/f Luminance: `+cstrf[getcharquadprop[6], `N0`]}
				SetState {Idle}

	~~ Handle `#check level`
	IF: Expr {(level)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/f Level: `+getcharintprop[25]}
				SetState {Idle}

	~~ Handle `#check landblock`
	IF: Expr {(landblock)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/f Landblock: `+hexstr[getplayerlandblock[]]}
				SetState {Idle}

	~~ Handle `#check landcell`
	IF: Expr {(landcell)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/f Landblock: `+hexstr[getplayerlandcell[]]}
				SetState {Idle}

	~~ Handle no match for checktext
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching action for #check`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {AutoLoot} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Always
		DO: DoAll
				DoExpr {setvar[$AUTO_LOOT_CORPSES, dictcreate[]]}

	~~ Warn if there are no corpses
	IF: Expr {listcount[wobjectfindalllandscapebyobjectclass[$CORPSE]]==0}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] No corpses found\`, $COLOR_WARN]`, `false`]}
				SetState {Idle}

~~ }


STATE: {Loot} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}


	IF: Always
		DO: DoAll
				DoExpr {$LootCorpseName=`Corpse of .*`}
				DoExpr {$LootCorpseItem=`Greater Mana Stone`}

	~~ Find Potential Corpses
	IF: Always
		DO: DoAll
				DoExpr {$allCorpses=wobjectfindalllandscapebynamerx[$LootCorpseName]}
				DoExpr {$foundCorpses=listfilter[$allCorpses, `listfilter[$allCorpses, \`listcontains[$CorpseBlacklist, wobjectgetid[$1]]==false\`]`]}

	~~ Out of corpses
	IF: Expr {listcount[$foundCorpses]==0}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] No corpse found for \`+$LootCorpseName, $COLOR_WARN]`, `false`]}
				SetState {Idle}

	~~ OpenCorpse of first foundCorpse
	IF: Expr {listcount[$foundCorpses]>0}
		DO: DoAll
				DoExpr {$Corpse=listpop[$foundCorpses, 0]}
				SetState {OpenCorpse}

~~ }

STATE: {OpenCorpse} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Has an open corpse
	IF: Expr {getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Opened corpse\`, $COLOR_INFO]`, `false`]}
				SetState {LootCorpse}

	~~ Try opening the corpse
	IF: Always
		DO: DoAll
				DoExpr {$actiontryuseitem[$Corpse]}
				SetState {OpenCorpse}

~~ }


STATE: {LootCorpse} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Always
		DO: DoAll
				DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Looting corpse\`, $COLOR_INFO]`, `false`]}

	IF: Always
		DO: DoAll
				DoExpr {$CorpseItems=wobjectfindallbycontainer[wobjectgetopencontainer[]]}
				DoExpr {$CorpseItemsWanted=listfilter[$CorpseItems, `wobjectgetstringprop[$1, $STRING_PROP_NAME]==$LootCorpseItem`]}

	IF: Expr {listcount[$CorpseItemsWanted]==0}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] Did not find the item \`+$LootCorpseItem+\` on \`+$LootCorpseName, $COLOR_WARN]`, `false`]}
				DoExpr {actiontryuseitem[wobjectgetopencontainer[]]}
				DoExpr {listadd[$CorpseBlacklist, wobjectgetid[$Corpse]]}
				SetState {Loot}

	IF: Expr {listcount[$CorpseItemsWanted]>0}
		DO: DoAll
				DoExpr {$item=listpop[$CorpseItemsWanted, 0]}
				DoExpr {actiontryuseitem[$item]}
				SetState {LootCorpse}

	~~ /ub mexec wobjectgetstringprop[wobjectfindallbycontainer[wobjectgetopencontainer[]]{0}, 1]
	~~ Ghost items in the inventory can be handled by getbusy or setting a timer and waiting

~~ }


STATE: {Portal} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Portal}

	~~ Use the Portal
	IF:	Expr {isportaling[]==false}
		DO:	DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$PORTAL]]}
				SetState {Portal}

	~~ Finished using portal; reset options to what they originally were
	IF:	Expr {isportaling[]==true}
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, Finished using portal\`]`, `false`]}
				CallState {EnableOptions} {Idle}

~~ }


STATE: {VRPortal} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {VRPortal}

	~~ Use the VR portal
	IF:	Expr {isportaling[]==false}
		DO:	DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbynameandobjectclass[$NPC, `Viridian Portal`]]}
				SetState {VRPortal}

	~~ Finished using portal; reset options to what they originally were
	IF:	Expr {isportaling[]==true}
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, Finished using VR portal\`]`, `false`]}
				CallState {EnableOptions} {Idle}

~~ }


STATE: {CreateFellow} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Create the fellow
	IF:	Always
		DO:	ChatExpr {`/ub fellow create `+@CCFellowname}

	~~ If fellow is created move to InviteFellow
	IF:	Expr {getfellowshipstatus[]==1}
		DO:	SetState {InviteFellow}

	~~ If fellow isn't created try again
	IF:	SecsInStateGE 1
		DO:	SetState {CreateFellow}

~~ }


STATE: {InviteFellow} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Create blacklist
	IF: Expr {testvar[FellowBlacklist]==false}
		DO: DoExpr {$FellowBlacklist=listcreate[]}

	~~ Find all nearby players who are in @CCCharacterList
	IF: Always
		DO: DoAll
				DoExpr {$AllNearbyPlayers=listmap[wobjectfindallbyobjectclass[$PLAYER],`wobjectgetstringprop[$1,1]`]}
				DoExpr {$AllNearbyCharacterList=listfilter[$AllNearbyPlayers, `listcontains[@CCCharacterList, $1]`]}
				DoExpr {$AllNearbyNotInFellow=listfilter[$AllNearbyCharacterList, `listcontains[getfellownames[], $1]==false`]}
				DoExpr {$AllNearbyNotInFellowNotBlacklisted=listfilter[$AllNearbyNotInFellow, `listcontains[$FellowBlacklist, $1]==false`]}

	~~ Clear variables and return to idle if there are no more players to add
	IF: Expr {listcount[$AllNearbyNotInFellowNotBlacklisted]==0}
		DO: DoAll
				DoExpr {listmap[listcreate[`AllNearbyPlayers`, `AllNearbyCharacterList`, `AllNearbyNotInFellow`, `AllNearbyNotInFellowNotBlacklisted`, `FellowBlacklist`, `name`], `clearvar[$1]`]}
				SetState {Idle}
	
	~~ Blacklist the character if already in a fellow
	IF: ChatMatch {is already a member of a Fellowship.$}
		DO: DoAll
				DoExpr {listadd[$FellowBlacklist, $name]}
				SetState {InviteFellow}

	~~ Recruit a nearby player in $CCCharacterlist
	IF: Always
		DO: DoAll
				DoExpr {$name=listpop[$AllNearbyNotInFellowNotBlacklisted, 0]}
				ChatExpr {`/ub fellow recruit `+$name}
				SetState {InviteFellow}

~~ }


STATE: {HandleRecall} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Return to Idle if the spell isn't known
	IF: Not Expr {getisspellknown[$CCRecallSpell]}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, I do not know this recall spell\`]`, `false`]}
				SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {HandleRecall}

	~~ Cast the recall spell
	IF: Expr {isportaling[]==false}
		DO: DoAll
				DoExpr {actiontrycastbyid[$CCRecallSpell]}
				SetState {HandleRecall}

	~~ Finished recalling; reset EnableNav to what it originally was
	IF: Expr {isportaling[]==true}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, Finished recalling\`]`, `false`]}
				CallState {EnableOptions} {Idle}

~~}


STATE: {UseNPC} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UseNPC}

	~~ Stop using NPC if you receieve a response
	IF:	Any
			All
				ChatCapture {^(?<tellname>.*?) tells you, \"(?<npctext>.*)\"$} {}
				Expr {$capturegroup_tellname==$name}
			All
				ChatCapture {^(?<tellname>.*?) gives you (?<npctext>.*)$} {}
				Expr {$capturegroup_tellname==$name}
			All
				ChatCapture {^(?<tellname>.*?) cast (?<npctext>.*)$} {}
				Expr {$capturegroup_tellname==$name}
			ChatMatch {^You've earned}
			ChatMatch {^You may complete this quest}
			ChatMatch {^A plaque on}
			ChatMatch {^You have already gained}
			ChatMatch {^You shock yourself}
			ChatMatch {^As you touch}
			ChatMatch {^A voice in your mind}
			ChatMatch {^According to the plaque}
			ChatMatch {^You search through the parts}
			ChatMatch {^You must wait}
			ChatMatch {^The stone eyes widens}
			ChatMatch {^Looking at the tusker corpse} ~~ Slain Protectorate
			ChatMatch {^You have killed} ~~ Slain Protectorate
			IntoPortal
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, Talked to \`+$name]`, `false`]}
				CallState {EnableOptions} {Idle}

	~~ Use NPC
	IF: Always
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$NPC]]}
				DoExpr {$name=wobjectgetstringprop[wobjectfindnearestbyobjectclass[$NPC], $SRING_PROP_NAME]}
				SetState {UseNPC}

~~ }


STATE: {UseVendor} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UseVendor}
	
	~~ Autovendor finished
	IF:	ChatMatch {^You think, "AutoVendor finished}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, Finished vending with \`+$name]`, `false`]}
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$VENDOR]]} ~~ Close the vendor window
				DoExpr {clearvar[open]}
				CallState {EnableOptions} {Idle}

	~~ Use Vendor
	IF: VendorClosed 
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$VENDOR]]}
				DoExpr {$name=wobjectgetstringprop[wobjectfindnearestbyobjectclass[$VENDOR], $SRING_PROP_NAME]}
				SetState {UseVendor}

~~ }


STATE: {ReadContracts} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {$CCReset=true}
				SetState {Finished}

	~~ If Remaining contracts try using them
	IF: Expr {getitemcountininventorybynamerx[`(Hunting\: Lost City of Neftet)|(Contract for)`]>0}
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindininventorybynamerx[`(Hunting\: Lost City of Neftet)|(Contract for)`]]}
				SetState {ReadContracts}

	~~ No contracts left return to Idle
	IF: Expr {getitemcountininventorybynamerx[`(Hunting\: Lost City of Neftet)|(Contract for)`]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true&&testvar[`capturegroup_name`]==true, `chatbox[\`/t \`+$capturegroup_name+\`, Finished reading contracts\`]`, `false`]}
				SetState {Idle}

~~ }


STATE: {DisableOptions} ~~ {

	~~ Store original options so we can reset them
	IF: Always
		DO: DoAll
				DoExpr {setvar[OriginalEnableNav, vtgetsetting[EnableNav]]}
				DoExpr {setvar[OriginalEnableCombat, vtgetsetting[EnableCombat]]}
				DoExpr {setvar[OriginalEnableBuffing, vtgetsetting[EnableBuffing]]}
				DoExpr {setvar[OriginalEnableLooting, vtgetsetting[EnableLooting]]}
				DoExpr {setvar[OptionsSet, true]}

	~~ Disable all options
	IF:	Always
		DO:	DoAll
				SetOpt {EnableNav} {False}
				SetOpt {EnableCombat} {False}
				SetOpt {EnableBuffing} {False}
				SetOpt {EnableLooting} {False}

	~~ Return
	IF: Always
		DO: Return

~~ }


STATE: {EnableOptions} ~~ {

	~~ Enable options
	IF:	Always
		DO:	DoAll
				SetOpt {EnableNav} {$OriginalEnableNav}
				SetOpt {EnableCombat} {$OriginalEnableCombat}
				SetOpt {EnableBuffing} {$OriginalEnableBuffing}
				SetOpt {EnableLooting} {$OriginalEnableLooting}

	~~ Clear all vars
	IF: Always
		DO: DoAll
				DoExpr {clearvar[OriginalEnableNav]}
				DoExpr {clearvar[OriginalEnableCombat]}
				DoExpr {clearvar[OriginalEnableBuffing]}
				DoExpr {clearvar[OriginalEnableLooting]}
				DoExpr {clearvar[OptionsSet]}

	~~ Return
	IF: Always
		DO: Return

~~ }


STATE: {ShowJump} ~~ {

	IF: Not Expr {uiviewvisible[Jump]}
		DO: DoAll
				CreateView {Jump} {:CheCommand-Jump.xml}
				SetState {Idle}

	IF: Expr {uiviewvisible[Jump]}
		DO: DoAll
				DestroyView {Jump}
				SetState {Idle}
~~ }


~~ Use Virindi Hotkey System to map this state to a key like `tab` to toggle on and off combat/healing/buffing
STATE: {HotkeyToggleVitals} ~~ {
	IF: Expr {$Vitals==1}
		DO: DoAll
				DoExpr {$Vitals=0}
				DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Turning off vitals\`, $COLOR_INFO]`, `false`]}
				DoExpr {vtsetsetting[EnableBuffing, `0`]}
				DoExpr {vtsetsetting[EnableCombat, `0`]}
				DoExpr {vtsetsetting[Recharge-Norm-HitP, `0`]}
				DoExpr {vtsetsetting[Recharge-Norm-Stam, `0`]}
				DoExpr {vtsetsetting[Recharge-Norm-Mana, `0`]}
				DoExpr {vtsetsetting[Recharge-Helper-HitP, `0`]}
				SetState {Idle}

	IF: Expr {$Vitals==0}
		DO: DoAll
				DoExpr {$Vitals=1}
				DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Turning on vitals\`, $COLOR_INFO]`, `false`]}
				DoExpr {vtsetsetting[EnableBuffing, `0`]}
				DoExpr {vtsetsetting[EnableBuffing, `0`]}
				DoExpr {vtsetsetting[EnableBuffing, `1`]}
				DoExpr {vtsetsetting[EnableCombat, `1`]}
				DoExpr {vtsetsetting[Recharge-Norm-HitP, `75`]}
				DoExpr {vtsetsetting[Recharge-Norm-Stam, `50`]}
				DoExpr {vtsetsetting[Recharge-Norm-Mana, `50`]}
				DoExpr {vtsetsetting[Recharge-Helper-HitP, `75`]}
				SetState {Idle}

	IF: Always
		DO: SetState {Idle}
~~ }

NAV: Empty once ~~ {
~~