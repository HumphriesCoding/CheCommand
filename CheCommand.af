~~ {
~~ FOR AUTO-COMPLETION ASSISTANCE: testvar getvar setvar touchvar clearallvars clearvar getcharintprop getchardoubleprop getcharquadprop getcharboolprop getcharstringprop getisspellknown getcancastspell_hunt getcancastspell_buff getcharvital_base getcharvital_current getcharvital_buffedmax getcharskill_traininglevel getcharskill_base getcharskill_buffed getplayerlandcell getplayercoordinates coordinategetns coordinategetwe coordinategetz coordinatetostring coordinateparse coordinatedistancewithz coordinatedistanceflat wobjectgetphysicscoordinates wobjectgetname wobjectgetobjectclass wobjectgettemplatetype wobjectgetisdooropen wobjectfindnearestmonster wobjectfindnearestdoor wobjectfindnearestbyobjectclass wobjectfindininventorybytemplatetype wobjectfindininventorybyname wobjectfindininventorybynamerx wobjectgetselection wobjectgetplayer wobjectfindnearestbynameandobjectclass actiontryselect actiontryuseitem actiontryapplyitem actiontrygiveitem actiontryequipanywand actiontrycastbyid actiontrycastbyidontarget chatbox chatboxpaste statushud statushudcolored uigetcontrol uisetlabel isfalse istrue iif randint cstr strlen getobjectinternaltype cstrf stopwatchcreate stopwatchstart stopwatchstop stopwatchelapsedseconds cnumber floor ceiling round abs getworldname getitemcountininventorybyname getheading getitemcountininventorybynamerx getheadingto actiontrygiveprofile vitae getfellowshipstatus getfellowshipname getfellowshipisopen getfellowshipisleader getfellowshipleaderid getfellowshipcanrecruit getfellowid getfellowshipcount getfellowshiplocked getfellowname getfellowshipisfull sin cos tan sqrt asin acos atan atan2 sinh cosh tanh vtsetmetastate getregexmatch echo chr ord wobjectgetid wobjectgethealth wobjectfindbyid wobjectgetintprop wobjectfindnearestbytemplatetype wobjectgetopencontainer testquestflag getquestktprogress isrefreshingquests getquestktrequired getqueststatus getisday getgamehour getgamehourname getisnight getgameday getgameticks getminutesuntilday getgamemonth getgamemonthname getminutesuntilnight getgameyear uisetvisible uiviewvisible uiviewexists getgvar touchgvar getpvar touchpvar setgvar cleargvar setpvar clearpvar testgvar clearallgvars testpvar clearallpvars dictgetitem dictcreate dicthaskey dictadditem dictkeys dictremovekey dictvalues dictclear dictsize dictcopy listgetitem listpop listcreate listcontains listremove listadd listindexof listremoveat listinsert listlastindexof listclear listcopy listcount listreverse

~~																						
~~ File auto-generated by metaf, a program created by Eskarina of Morningthaw/Coldeve.	
~~		Get metaf here: https://github.com/JJEII/metaf/									
~~																						
~~ All recognized structural designators:												
~~		STATE:				DO:															
~~		IF:					NAV:														
~~																						
~~ All recognized CONDITION (IF:) operation keywords:									
~~		Never				NavEmpty			MobsInDist_Priority		Not				
~~		Always				Death				NeedToBuff				PSecsInStateGE	
~~		All					VendorOpen			NoMobsInDist			SecsOnSpellGE	
~~		Any					VendorClosed		BlockE					BuPercentGE		
~~		ChatMatch			ItemCountLE			CellE					DistToRteGE		
~~		MainSlotsLE			ItemCountGE			IntoPortal				Expr			
~~		SecsInStateGE		MobsInDist_Name		ExitPortal				ChatCapture		
~~																						
~~ All recognized ACTION (DO:) operation keywords:										
~~		None				EmbedNav			ChatExpr				SetOpt			
~~		SetState			CallState			SetWatchdog				CreateView		
~~		Chat				Return				ClearWatchdog			DestroyView		
~~		DoAll				DoExpr				GetOpt					DestroyAllViews	
~~																						
~~ All recognized NAV types:															
~~		circular			follow														
~~		linear				once														
~~																						
~~ All recognized NAV NODE types:														
~~		flw					vnd															
~~		pnt					ptl															
~~		rcl					tlk															
~~		pau					chk															
~~		cht					jmp															
~~		prt (deprecated in VTank)														
~~ }																					


STATE: {Default} ~~ {

	~~ Utility Belt Options
	IF: Always
		DO: DoAll
				Chat {/ub opt set VTank.PatchExpressionEngine true}
				Chat {/ub opt set Jumper.ThinkComplete true}
				Chat {/ub opt set Jumper.ThinkFail true}
				Chat {/ub opt set AutoVendor.Think true}

	~~ Constants
	IF: Always
		DO: DoAll

				DoExpr {setvar[NUMBER, 1]}
				DoExpr {setvar[MONSTER, 5]}
				DoExpr {setvar[OBJECT, 7]}
				DoExpr {setvar[PORTAL, 14]}
				DoExpr {setvar[PLAYER, 24]}
				DoExpr {setvar[VENDOR, 25]}
				DoExpr {setvar[CORPSE, 27]}
				DoExpr {setvar[NPC, 37]}

				DoExpr {setvar[STRING_PROP_NAME, 1]}
				DoExpr {setvar[STRING_PROP_DESCRIPTION, 16]}

				DoExpr {setvar[COLOR_DEBUG, 17]}
				DoExpr {setvar[COLOR_INFO, 5]}
				DoExpr {setvar[COLOR_WARN, 31]}
				DoExpr {setvar[COLOR_ERROR, 21]}

				DoExpr {setvar[LEVEL_DEBUG, 10]}
				DoExpr {setvar[LEVEL_INFO, 20]}
				DoExpr {setvar[LEVEL_WARN, 30]}
				DoExpr {setvar[LEVEL_ERROR, 40]}

				DoExpr {setvar[TYPE_NONE, 0]}
				DoExpr {setvar[TYPE_NUMBER, 1]}
				DoExpr {setvar[TYPE_STRING, 3]}
				DoExpr {setvar[TYPE_OBJECT, 7]}

				DoExpr {setvar[CLOSE_BLUE, 15]}

				DoExpr {setvar[CHARACTER_NAME, getcharstringprop[$STRING_PROP_NAME]]}

				DoExpr {setvar[RYNTHID_WEAPONS_PORTAL, 52012]}

	~~ Initialize CC variables
	IF: Always
		DO: DoAll
				DoExpr {setvar[CCVersion, `0.5.0`]}

				DoExpr {setpvar[CCDebug, ifthen[testpvar[CCDebug], `@CCDebug`, `$LEVEL_DEBUG`]]}
				DoExpr {setpvar[CCConfirm, ifthen[testpvar[CCConfirm], `@CCConfirm`, `true`]]}
				DoExpr {setpvar[CCFellowname, ifthen[testpvar[CCFellowname], `@CCFellowname`, `Not Set`]]}
				DoExpr {setpvar[CCCharacterList, ifthen[testpvar[CCCharacterList], `@CCCharacterList`, `listcreate[]`]]}

				~~ Amount of seconds between checking stuck
				DoExpr {setpvar[CCStuckAnnounceDelay, ifthen[testpvar[CCStuckAnnounceDelay], `@CCStuckAnnounceDelay`, `5`]]}

				~~ Maximum amount a character can move to determine stuck
				DoExpr {setpvar[CCStuckThreshold, ifthen[testpvar[CCStuckThreshold], `@CCStuckThreshold`, `1`]]}

				~~ Distance away a character must be to announce stuck
				DoExpr {setpvar[CCStuckDistanceThreshold, ifthen[testpvar[CCStuckDistanceThreshold], `@CCStuckDistanceThreshold`, `20`]]}

				~~ Leader to announce things to. Defaults to first character in @CCCharacterList and will update when follow commands are issued
				DoExpr {setpvar[CCLeader, ifthen[testpvar[CCLeader], `@CCLeader`, `listgetitem[@CCCharacterList, 0]`]]}

				~~ Distance to use the nearest Portal
				DoExpr {setpvar[CCPortalThreshold, ifthen[testpvar[CCPortalThreshold], `@CCPortalThreshold`, `30`]]}

				~~ Distance the leader needs to be within to leave LeaderCheck
				DoExpr {setpvar[CCLeaderCheckDistance, ifthen[testpvar[CCLeaderCheckDistance], `@CCLeaderCheckDistance`, `60`]]}

				~~ Are vitals on or off
				DoExpr {setpvar[CCVitals, ifthen[testpvar[CCVitals], `@CCVitals`, `true`]]}

				~~ Equip Item for handin
				DoExpr {setpvar[CCEquipOnTurnin, ifthen[testpvar[CCEquipOnTurnin], `@CCEquipOnTurnin`, `false`]]}

				~~ Are the followers staying
				DoExpr {setpvar[CCStay, ifthen[testpvar[CCStay], `@CCStay`, `true`]]}

				~~ Announce VR Blue
				DoExpr {setpvar[CCAnnounceVRBlue, ifthen[testpvar[CCAnnounceVRBlue], `@CCAnnounceVRBlue`, `true`]]}

				~~ Use Rynthid Weapons Portal
				DoExpr {setpvar[CCUseRynthidWeaponsPortal, ifthen[testpvar[CCUseRynthidWeaponsPortal], `@CCUseRynthidWeaponsPortal`, `true`]]}

				~~ Distance to recruit nearby players with `#fellow nearby`
				DoExpr {setpvar[CCFellowNearbyRecruitDistance, ifthen[testpvar[CCFellowNearbyRecruitDistance], `@CCFellowNearbyRecruitDistance`, `30`]]}

				~~ Maximum fellowship size
				DoExpr {setpvar[CCMaxFellowshipSize, ifthen[testpvar[CCMaxFellowshipSize], `@CCMaxFellowshipSize`, `9`]]}

				~~ Use Auto Timers
				DoExpr {setpvar[CCAutoTimers, ifthen[testpvar[CCAutoTimers], `@CCAutoTimers`, `true`]]}

				~~ Profiles (UB does not support dictionaries in pvars so using two lists instead)
				DoExpr {setpvar[CCProfileKeys, ifthen[testpvar[CCProfileKeys], `@CCProfileKeys`, `listcreate[]`]]}
				DoExpr {setpvar[CCProfileValues, ifthen[testpvar[CCProfileValues], `@CCProfileValues`, `listcreate[]`]]}

				~~ Profiles landcells (UB does not support dictionaries in pvars so using two lists instead)
				DoExpr {setpvar[CCProfileLandcellKeys, ifthen[testpvar[CCProfileLandcellKeys], `@CCProfileLandcellKeys`, `listcreate[]`]]}
				DoExpr {setpvar[CCProfileLandcellValues, ifthen[testpvar[CCProfileLandcellValues], `@CCProfileLandcellValues`, `listcreate[]`]]}

				~~ Amount of time to surpress announcing available looting in seconds
				DoExpr {setpvar[CCAnnounceLootingTimeout, ifthen[testpvar[CCAnnounceLootingTimeout], `@CCAnnounceLootingTimeout`, `60`]]}

				~~ Amount of time to surpress announcing available giving in seconds
				DoExpr {setpvar[CCAnnounceGivingTimeout, ifthen[testpvar[CCAnnounceGivingTimeout], `@CCAnnounceGivingTimeout`, `60`]]}

				~~ Spell to use to check time remaining on buffs. This cannot be a spell that is in your suit. Only self casted spells will give the correct time remaining.
				DoExpr {setpvar[CCCheckBuffsSpell, ifthen[testpvar[CCCheckBuffsSpell], `@CCCheckBuffsSpell`, `Jumping Mastery Self`]]}

				~~ Amount of time left in buffs duration to warn about low buffs. Defaults to 30 minutes.
				DoExpr {setpvar[CCWarnBuffsDuration, ifthen[testpvar[CCWarnBuffsDuration], `@CCWarnBuffsDuration`, `1800`]]}

				~~ Amount of time to surpress announcing when buffs are low
				DoExpr {setpvar[CCAnnounceBuffsTimeout, ifthen[testpvar[CCAnnounceBuffsTimeout], `@CCAnnounceBuffsTimeout`, `300`]]}


				DoExpr {setvar[AutoTimers, listcreate[]]}
				DoExpr {listadd[$AutoTimers, listcreate[11, 00, 00, `AM`, listcreate[`CheCommandNavRecomp`, `CheCommandNavChair`]]]}

				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 20, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 21, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 22, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 23, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 24, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 25, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 26, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 27, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 28, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 29, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}

				~~ Nav Routes
				~~ Keys are landcells in hexidecimal format, values are the name of the nav file without the file extension
				DoExpr {setvar[CCRoutes, dictcreate[]]}
				DoExpr {dictadditem[$CCRoutes, `59540817`, `CC-Catacombs of Torment`]}
				DoExpr {dictadditem[$CCRoutes, `002C029C`, `CC-Forgotten Chasm`]}
				DoExpr {dictadditem[$CCRoutes, `472D0107`, `CC-Massilor's Crypt`]}
				DoExpr {dictadditem[$CCRoutes, `00060100`, `CC-Western Power Forge`]}
				DoExpr {dictadditem[$CCRoutes, `002E02D1`, `CC-Feeding Tube`]}
				DoExpr {dictadditem[$CCRoutes, `5879052B`, `CC-Path of Rage`]}
				DoExpr {dictadditem[$CCRoutes, `5E450375`, `CC-Black Death Catacombs`]}

	~~ Setup Auto Giving
	IF: Always
		DO: DoAll
				DoExpr {setvar[AUTOGIVE_PROFILE, dictcreate[]]}

				~~ Sundering Quests
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Liora Fenn`, `Bitter Tongue's Head`]} ~~ Drudge Hideout Infiltration
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Emissary of Asheron`, listcreate[`Virindi Observer's Message Shard`, `Dark Apostate Shard`, `Engorged Bloodstone Shards`, `Virindi Armorer's Message Shard`, `Dericost Gem of Luminance`]]} ~~ Return to Frore, Empyrean Rescue
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Zervakarix`, `Viridian Rise Pocket Watch`]} ~~ Return to Frore

				~~ Legendary Quests
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Uber P`, `Letter from Mouf`]} ~~ Rescuing Mouf P
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mr. P`, listcreate[`Letter from Mouf and Uber P`, `Pet Mouf Igloo`]]} ~~ Rescuing Mouf P
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kraytuss Nallah`, `Bone Fragment from Shikken Moriyaki`]} ~~ Serpent Burial Grounds
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Collector Golem`, listcreate[`Glowing Statue Shard`, `Essence of the Sundered`, `Empowered Empyrean Robe`]]} ~~ Saving Asheron
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fanzen San the Translator`, listcreate[`Complete Page of Lost Lore`, `Orders for Zrikux`]]} ~~ Lost Lore, Falacot Depot
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Popkin of the Gate`, `The Story of the Lost Sisters`]} ~~ Lost Lore
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Ruby Annex`, `Shroud of Bloodlust`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Amethyst Annex`, `Shroud of Spite`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Jade Annex`, `Shroud of Envy`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Sapphire Annex`, `Shroud of Apathy`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Rinne Gorber`, listcreate[`Spirit Crystal`, `Spirited Bloodlust Guard`]]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Lady Daenerah`, `Sealed Tome`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mareeno Donn`, `First Lieutenant's Insignia.`]} ~~ Hoshino Infiltration
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fahneph`, `Ancient Falatacot Symbol`]} ~~ Foundry of Izexi
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mhoire Soldier`, `Book`]} ~~ Geraine's Study
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Commander Presk`, `Sealed Scroll for Commander Presk`]} ~~ Lugian Assault
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Raksaa`, listcreate[`Sealed Scroll for Raksaa`, `Casting Stone`]]} ~~ Lugian Assault
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Aun Ol'tra`, listcreate[`Crimson Scarab`, `Purified Crimson Scarab`]]} ~~ End of Days
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Morgethais`, `Shard of the Curator of Torment's Mask`]} ~~ Defeating the Curator of Torment
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Spirit of Bist'elle`, `Mirror Shard`]} ~~ Hoshino Must Die
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mortified Soldier`, `Torn Note`]} ~~ Gurog Creation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fayza`, listcreate[`Journal of a Soldier`, `Energy Infused Rock`]]} ~~ Gurog Creation, Deewains
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kuyiza bint Zayi the Translator`, listcreate[`Carefully rolled scroll`, `Large Tome`]]} ~~ Bloodstone Investigation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Sir Donovan`, listcreate[`Bloodstone Report`, `Research Notes`, `Shattered Master Bloodstone Shard`, `Delicate Bloodstone Wand`, `Sturdy Bloodstone Wand`]]} ~~ Bloodstone Investigation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Virindi Delegate`, listcreate[`Olthoi Hive Queen Carapace`, `Virindi Sentinel's Message Shard`]]} ~~ Hive Queen Assault, Dream Reaver Investigation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mhoire Lieutenant`, `Geraine's Tome \\(1\\)`]} ~~ Geraine's Hosts
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Darviss`, `Spectral Nanjou Master's Sword`]} ~~ Ninja Academy
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kinchou`, `Coded Tanada Scroll`]} ~~ Tanada Intercept
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kousha`, `Tanada Neophyte's Mask`]} ~~ Tanada Slaughter
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Shorikan`, `Spectral Nanjou Zaikan's Sword`]} ~~ Nanjou Stockade
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `El'Yst Maggann`, `Idol of the Recluse`]} ~~ Four Corners
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Aetherium Ore`, `Tainted Aetherium Oil`]} ~~ Rynthid Foundry

				~~ Luminance Quests
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Aun Aemaua`, `Claw of the Hopeslayer`]} ~~ Ithaenc Quiddity Seed Quest
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Apostate Aetherium Deposit`, `Aetheric Resonator`]} ~~ Nexus Crawl
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Diyas al-Yat`, `Apostate Message Shard`]} ~~ Uncovering the Renegades
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Aruq ibn Balthar`, `Apostate Orders`]} ~~ Uncovering the Renegades
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Neelic`, `Translated Orders for Zrikux`]} ~~ Falacot Depot
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Omarah`, `Essence of Dravann`]} ~~ Virindi Rescue

				~~ Random
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fiun Rehlyun`, `Insatiable Eater Jaw`]} ~~ Blank Aug Gem
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mana Siphon`, `Unstable Mana Stone`]} ~~ Society
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kervim'telek`, listcreate[`Essence of Norshuntyr`, `Essence of Night Brier`, `Essence of Wind Fury`, `Essence of Zerzelikyr`]]} ~~ Virindian Rise
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `The Deep`, `Altered Dark Remoran Fin`]} ~~ Society
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Lord Kresovus`, `Sigil of Linvak Tukal`]} ~~ Aerbax's Prodigal Lugian
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Master of the Gauntlet`, `Holcha's Head`]} ~~ Holcha's Head

	~~ Setup Auto Looting
	IF: Always
		DO: DoAll
				DoExpr {setvar[AUTO_LOOT_CORPSES, dictcreate[]]}

				~~ Sundering Quests
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Bitter Tongue`, `Bitter Tongue's Head`]} ~~ Drudge Hideout Infiltration
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Ler Rhan`, `Dericost Gem of Luminance`]} ~~ Uber Nexus
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Nexus Crystal`, `Nexus Core Gem`]} ~~ Uber Nexus

				~~ Legendary Quests
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Izexi`, `Ancient Falatacot Symbol`]} ~~ Foundry of Izexi Quest
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Shikken Moriyaki`, `Bone Fragment from Shikken Moriyaki`]} ~~ Serpent Burial Grounds
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Falatacot Blood Prophetess`, `Torn Strip of Parchment`]} ~~ Serpent Burial Grounds
				~~ DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Gurog Minion`, `Torn Note`]} ~~ Gurog Creation
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Virindi Sentinel`, `Virindi Sentinel's Message Shard`]} ~~ Dream Reaver Investigation
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Lord Winstead`, `Sealed Tome`]} ~~ Halt Dericost Ritual
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Bah'Ktar`, `Crimson Scarab`]} ~~ 
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Kul Bronzegear`, `Legendary Key`]} ~~ Purging the Corruption
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Lord Kastellar`, `Large Tome`]} ~~ Bloodstone Investigation
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Treasure of Master Bloodstone`, `Shattered Master Bloodstone Shard`]} ~~ Bloodstone Investigation
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Geraine`, `Book`]} ~~ Geraine's Study
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Materialized Hoshino Kei`, `Mirror Shard`]} ~~ Hoshino Must Die

				~~ Luminance Quests
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Zrikux`, `Orders for Zrikux`]} ~~ Falacot Depot

				~~ Random
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Battle Lord Gregor`, `Battle Lord Gregor's Mnemosyne`]} ~~ Luminance Flagging
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Shadow Kresovus`, `Sigil of Linvak Tukal`]} ~~ Aerbax's Prodigal Lugian
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Holcha`, `Holcha's Head`]} ~~ Holcha
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Zerzelikyr`, `Essence of Zerzelikyr`]} ~~ VR Boss
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of NightBrier`, `Essence of NightBrier`]} ~~ VR Boss
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Wind Fury`, `Essence of Wind Fury`]} ~~ VR Boss
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Norshuntyr`, `Essence of Norshuntyr`]} ~~ VR Boss
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Paradox-touched Olthoi Queen`, `Carapace Shard`]} ~~ Paradox-touched Olthoi Queen

	~~ Open Remote view
	IF: Always
		DO:	CreateView {Main} {:CheCommand-Main.xml}

	IF:	Expr {$LEVEL_DEBUG>=@CCDebug}
		DO:	DoExpr {echo[`[DEBUG] Che Command v`+$CCVersion+` by Che de Pa of Sundering`, $COLOR_DEBUG]}

	IF: Always
		DO: SetState {Init}
~~ }


STATE: {Init} ~~ {

	~~ If $MetaCallQueue is not a list create it
	IF: Expr {testvar[MetaCallQueue]==0}
		DO: DoExpr {setvar[MetaCallQueue, listcreate[]]}

	~~ Show Debug info about $MetaCallQueue
	IF: All
			Expr {listcount[$MetaCallQueue]>0}
			Expr {$LEVEL_DEBUG>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[DEBUG] $MetaCallQueue => `+$MetaCallQueue, $COLOR_DEBUG]}

	~~ Clear $MetaCallQueue if reset was used
	IF: Expr {$CCReset==true}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] Reset was called! Clearing queue\`, $COLOR_WARN]`, `false`]}
				DoExpr {listclear[$MetaCallQueue]}
				DoExpr {$CCReset=false}

	~~ Handle calling metas if there's some left in the queue
	IF: Expr {listcount[$MetaCallQueue]>0}
		DO: SetState {CallMeta}

	IF: Always
		DO: DoAll
				DoExpr {setvar[FoundTimers, listcreate[]]}

				DoExpr {setvar[CorpseBlacklist, listcreate[]]}
				DoExpr {setvar[StuckTimer, stopwatchstart[stopwatchcreate[]]]}
				DoExpr {$InitialPosition=getplayercoordinates[]}
				DoExpr {$InitialDistance=0}

				DoExpr {setvar[BlueSeen, listcreate[]]}

	IF: Any
			Expr {listcount[@CCCharacterList]==0}
			Expr {@CCFellowname==`Not Set`}
		DO: SetState {Setup}

	~~ Wait for Leader if supposed to be following
	IF: All
			Expr {listcount[$MetaCallQueue]==0}
			Expr {@CCStay==false}
			Expr {@CCLeader!=$CHARACTER_NAME}
		DO: SetState {LeaderCheck}

	IF: Always
		DO: SetState {SetupButtons}

~~ }


STATE: {Setup} ~~ {
	IF: Always
		DO: DoAll
				DoExpr {echo[`SETUP:`, $COLOR_DEBUG]}
				DoExpr {echo[`1) Add characters: /ub mexec @CCCharacterList=listcreate[\`First Character\`, \`Second Character\`, \`Third Character\`]`, $COLOR_DEBUG]}
				DoExpr {echo[`2) Set fellow name: /ub mexec @CCFellowname=\`Example Army\``, $COLOR_DEBUG]}
				DoExpr {echo[`3) Restart: !start`, $COLOR_DEBUG]}

	IF:	ChatMatch {![Ss]tart}
		DO: DoAll
				DoExpr {@CCLeader=listgetitem[@CCCharacterList, 0]}
				Chat {/vt meta load CheCommand}
~~ }


STATE: {Idle} ~~ {

	~~ Announce if stuck
	IF: All
			Expr {@CCStay==false} ~~ Characters are following
			Expr {@CCLeader!=$CHARACTER_NAME} ~~ Not the leader
			Expr {getobjectinternaltype[$leaderObj]==$TYPE_OBJECT} ~~ Leader exists
			Expr {stopwatchelapsedseconds[$StuckTimer]>=@CCStuckAnnounceDelay} ~~ Announce when the $StuckTimer is above the delay
			Expr {coordinatedistancewithz[$InitialPosition, getplayercoordinates[]]<=@CCStuckThreshold} ~~ Character has not moved past the threshold
			Expr {getmotion[Forward]!=0} ~~ Character is moving
			Expr {isportaling[]==false} ~~ Character is not portaling
			Expr {$finalDistance=coordinatedistancewithz[wobjectgetphysicscoordinates[$leaderObj], getplayercoordinates[]]} ~~ Set $finalDistance
			Expr {$finalDistance>=@CCStuckDistanceThreshold} ~~ The distance to the leader is greater than the threshold
			Not Expr {$finalDistance>1000} ~~ The leader hasn't portaled away
		DO: DoAll
				ChatExpr {`/t `+@CCLeader+`, I am stuck and you are `+floor[$finalDistance]+` meters away!`}
				~~ ChatExpr {`/f InitialDistance: `+floor[$finalDistance]}
				~~ ChatExpr {`/f finalDistance: `+floor[$finalDistance]}
				SetState {Idle}

	~~ Restart stuck stopwatch
	IF: All
			Expr {@CCLeader!=$CHARACTER_NAME}
			Expr {stopwatchelapsedseconds[$StuckTimer]>=5}
		DO: DoAll
				DoExpr {$leaderObj=wobjectfindnearestbynameandobjectclass[$PLAYER, @CCLeader]}
				DoExpr {setvar[StuckTimer, stopwatchstart[stopwatchcreate[]]]}
				~~ DoExpr {$InitialDistance=coordinatedistancewithz[wobjectgetphysicscoordinates[$leaderObj], getplayercoordinates[]]}
				DoExpr {$InitialPosition=getplayercoordinates[]}
				SetState {Idle}

	~~ Use VR portal
	IF:	All
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$NPC, `Viridian Portal`]]==$OBJECT}
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$NPC, `Viridian Portal`]],getplayercoordinates[]]<$CLOSE_BLUE}
		DO:	SetState {UseVRPortal}

	~~ Find nearest Blue
	IF: All
			Expr {@CCAnnounceVRBlue==true}
			Expr {wobjectfindnearestbynameandobjectclass[$NPC, `Fiery Remains`]}
			Not Expr {listcontains[$BlueSeen, wobjectgetid[wobjectfindnearestbynameandobjectclass[$NPC, `Fiery Remains`]]]}
		DO: DoAll
				~~ coordinateparse in VTank does not output the height so we turn off the PatchExpressionEngine to use VTank instead of UtilityBelt
				Chat {/ub opt set VTank.PatchExpressionEngine false}
				ChatExpr {`Found Blue at `+coordinatetostring[coordinateparse[coordinatetostring[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[37, `Fiery Remains`]]]]]}  ~~ Can't use getvar for some reason throws error. 37=NPC
				Chat {/ub opt set VTank.PatchExpressionEngine true}
				
				ChatExpr {`/goarrow to `+coordinatetostring[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$NPC, `Fiery Remains`]]]}
				
				DoExpr {listadd[$BlueSeen, wobjectgetid[wobjectfindnearestbynameandobjectclass[$NPC, `Fiery Remains`]]]}
				SetState {Idle}

	~~ Start stopwatch when Rynthid Weapons greentext appears
	IF: All
			CellE 2D310025  ~~ Next to Rynthid Weapons Portal
			Expr {@CCUseRynthidWeaponsPortal==true}
			ChatMatch {^With the last of the Warding Crystals shattered}
		DO: DoAll
				DoExpr {setvar[RynthidPortalWait, stopwatchstart[stopwatchcreate[]]]}
				SetState {Idle} 

	~~ Use Rynthid Weapons portal after the stopwatch expires
	IF: All
			CellE 2D310025  ~~ Next to Rynthid Weapons Portal
			Expr {@CCUseRynthidWeaponsPortal==true}
			Expr {testvar[RynthidPortalWait]!=0}
			Expr {stopwatchelapsedseconds[$RynthidPortalWait]>=10}
			Expr {wobjectfindnearestbytemplatetype[$RYNTHID_WEAPONS_PORTAL]!=0}
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbytemplatetype[$RYNTHID_WEAPONS_PORTAL]], getplayercoordinates[]]<=@CCPortalThreshold}
		DO: DoAll
				DoExpr {clearvar[RynthidPortalWait]}
				SetState {UsePortal} 

	~~ Clear Rynthid Weapons stopwatch if not within range
	IF: All
			Expr {@CCUseRynthidWeaponsPortal==true}
			Expr {testvar[RynthidPortalWait]!=0}
			Expr {stopwatchelapsedseconds[$RynthidPortalWait]>=15}
			Expr {wobjectfindnearestbytemplatetype[$RYNTHID_WEAPONS_PORTAL]==0}
		DO: DoAll
				DoExpr {clearvar[RynthidPortalWait]}
				SetState {UsePortal} 

	~~ Handle Auto Timers
	IF: All
			Expr {@CCAutoTimers==true}
			Expr {$FoundTimers=listfilter[$AutoTimers, `cnumber[getdatetimelocal[hh]]==$1{{0}}&&cnumber[getdatetimelocal[mm]]==$1{{1}}&&cnumber[getdatetimelocal[ss]]==$1{{2}}&&getdatetimelocal[tt]==$1{{3}}`]}
			Expr {listcount[$FoundTimers]>0}
		DO: SetState {HandleTimers} 

	~~ Display message if route is available
	IF: All
			ExitPortal	
			Expr {listcount[listfilter[dictkeys[$CCRoutes], `cstrf[getplayerlandcell[], \`X8\`]==$1`]]>0}
		DO: DoAll
				DoExpr {echo[`[INFO] Available route found!`, $COLOR_INFO]}
				SetState {Idle}

	~~ Display message if profile is available
	IF: All
			ExitPortal
			Expr {listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]!=-1}
		DO: DoAll
				DoExpr {echo[`[INFO] Available profile found!`, $COLOR_INFO]}
				SetState {Idle}

	~~ Display message if auto looting is available
	IF: All
			Expr {testvar[PreventAnnounceLooting]==false}
			Expr {listcount[listfilter[wobjectfindalllandscapebyobjectclass[$CORPSE], `listcontains[dictkeys[$AUTO_LOOT_CORPSES], wobjectgetstringprop[$1, $STRING_PROP_NAME]]`]]>0}
		DO: DoAll
				DoExpr {echo[`[INFO] Auto looting is available!`, $COLOR_INFO]}
				DoExpr {setvar[PreventAnnounceLooting, stopwatchstart[stopwatchcreate[]]]}
				SetState {Idle}

	~~ Clear $PreventAnnounceLooting stopwatch after timeout to re-enable announcements for when looting is available
	IF: All
			Expr {testvar[PreventAnnounceLooting]==true}
			Expr {stopwatchelapsedseconds[$PreventAnnounceLooting]>=@CCAnnounceLootingTimeout}
		DO: DoAll
				DoExpr {clearvar[PreventAnnounceLooting]}
				SetState {Idle}

	~~ Display message if auto giving is available
	IF: All
			Expr {testvar[PreventAnnounceGiving]==false}
			Expr {getobjectinternaltype[wobjectfindnearestbyobjectclass[$NPC]]==$TYPE_OBJECT}
			Expr {dicthaskey[$AUTOGIVE_PROFILE, wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]]}
		DO: DoAll
				DoExpr {echo[`[INFO] Auto giving is available!`, $COLOR_INFO]}
				DoExpr {setvar[PreventAnnounceGiving, stopwatchstart[stopwatchcreate[]]]}
				SetState {Idle}

	~~ Clear $PreventAnnounceGiving stopwatch after timeout to re-enable announcements for when giving is available
	IF: All
			Expr {testvar[PreventAnnounceGiving]==true}
			Expr {stopwatchelapsedseconds[$PreventAnnounceGiving]>=@CCAnnounceGivingTimeout}
		DO: DoAll
				DoExpr {clearvar[PreventAnnounceGiving]}
				SetState {Idle}

	~~ Display message if buffs are low
	IF: All
			Expr {testvar[PreventAnnounceBuffs]==false}
			Expr {getspellexpirationbyname[@CCCheckBuffsSpell]<=@CCWarnBuffsDuration}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, My buffs are low!\`]`, `false`]}
				DoExpr {setvar[PreventAnnounceBuffs, stopwatchstart[stopwatchcreate[]]]}
				SetState {Idle}

	~~ Clear $PreventAnnounceBuff stopwatch after timeout to re-enable announcements for when buffs are running low
	IF: All
			Expr {testvar[PreventAnnounceBuffs]==true}
			Expr {stopwatchelapsedseconds[$PreventAnnounceBuffs]>=@CCAnnounceBuffsTimeout}
		DO: DoAll
				DoExpr {clearvar[PreventAnnounceBuffs]}
				SetState {Idle}

	~~ Handle Actions
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#action (?<actiontext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleActions}	

	~~ Handle `#fellow add`
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#fellow add (?<namerx>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {FellowAdd}

	~~ Handle Fellows
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#fellow (?<fellowtext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleFellow}

	~~ Handle Navigation
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#navto (?<navdestination>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleNavigation}	

	~~ Handle Routes
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#route\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleRoute}	

	~~ Load Profiles
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#profile\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {AutoloadProfile}

	~~ Handle `#profile add`
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#profile add (?<profilename>.*) (?<profilevalue>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {ProfileAdd}

	~~ Handle `#profile addlandcell`
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#profile addlandcell (?<profilename>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {ProfileAddLandcell}

	~~ Handle `#profile load`
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#profile load (?<profilename>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {ProfileLoad}

	~~ Handle Profiles
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#profile (?<profiletext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleProfile}

	~~ Handle Killtasks
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#killtask (?<ktaction>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleKilltask}	

	~~ Handle Flaggings
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#flag (?<flagaction>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleFlagging}	

	~~ Handle Auto Looting
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#loot\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {AutoLoot}

	~~ Handle Looting
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#loot (?<item>.*) from (?<corpse>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleLooting}	

	~~ Handle Looting Info
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#loot (?<loottext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleLootingInfo}

	~~ Handle Facing a direction
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#face (?<facedirection>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleFace}	

	~~ Handle Jumping text
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#jump (?<jumptext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleJumping}	
	
	~~ Handle Picking up items
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#pickup (?<itemtext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandlePickup}	

	~~ Handle Auto Giving items
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#give\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {AutoGive}	

	~~ Handle Giving items
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#give (?<itemtext>.*) to (?<giveto>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleGive}	

	~~ Handle Passing items
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#pass (?<passtext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandlePass}	

	~~ Handle Checking
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#check (?<checktext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleCheck}

	~~ Handle VTank Options
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#vtoption (?<optiontext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: DoAll
				ChatExpr {`/vt opt set `+$capturegroup_optiontext}
				SetState {Idle}

	~~ Handle Echo
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#echo (?<echotext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: DoAll
				ChatExpr {$capturegroup_echotext}
				SetState {Idle}

	~~ Handle Version
	IF: ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#version\"$} {}
		DO: DoAll
				DoExpr {chatbox[`/t `+$capturegroup_name+`, CheCommand `+$CCVersion]}
				SetState {Idle}

~~ }


STATE: {HandleTimers} ~~ {

	~~ Return to Idle if no timers found
	IF: Expr {listcount[$FoundTimers]==0}
		DO: SetState {Idle}

	~~ Pop $FoundTimers and CallMeta
	IF: Always
		DO: DoAll
				DoExpr {$timer=listpop[$FoundTimers, 0]}
				DoExpr {$MetaCallQueue=$timer{{4}}}
				SetState {CallMeta}

~~ }

STATE: {CallMeta} ~~ {

	~~ Call a meta with the return meta being CheCommand
	IF: Expr {listcount[$MetaCallQueue]>0}
		DO: DoAll
				DoExpr {$meta=listpop[$MetaCallQueue, 0]}
				DoExpr {$CCReturnMeta=`CheCommand`}
				ChatExpr {`/vt meta load `+$meta}

~~ }


STATE: {HandleActions} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_actiontext]}
		DO: DoAll
				DoExpr {echo[`#action contracts: All characters read contracts in inventory`, $COLOR_INFO]}
				DoExpr {echo[`#action disband: Disbands the fellow`, $COLOR_INFO]}
				DoExpr {echo[`#action fellow: The person issuing the command creates a fellow`, $COLOR_INFO]}
				DoExpr {echo[`#action follow: All characters follow the initiator of the follow command`, $COLOR_INFO]}
				DoExpr {echo[`#action update: All characters reload the meta with the latest changes`, $COLOR_INFO]}
				DoExpr {echo[`#action mule: All characters navigate to Sort de Che and mule`, $COLOR_INFO]}
				DoExpr {echo[`#action npc: All characters use the nearest NPC`, $COLOR_INFO]}
				DoExpr {echo[`#action pack: All characters use mag tools auto pack`, $COLOR_INFO]}
				DoExpr {echo[`#action peace: All characters enter peace mode`, $COLOR_INFO]}
				DoExpr {echo[`#action portal: All characters use the nearest portal`, $COLOR_INFO]}
				DoExpr {echo[`#action quit: All characters exit the game`, $COLOR_INFO]}
				DoExpr {echo[`#action stay: All characters stop following`, $COLOR_INFO]}
				DoExpr {echo[`#action vendor: All characters use the nearest Vendor`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#action stay`
	IF: Expr {(stay)#getvar[capturegroup_actiontext]}	
		DO:	DoAll
				EmbedNav Empty {[None]}
				DoExpr {@CCStay=true}
				SetState {Idle}

	~~ Handle `#action follow` for followers
	IF:	All
			Expr {(follow)#getvar[capturegroup_actiontext]}
			Expr {$capturegroup_name!=false}
		DO:	DoAll
				SetOpt {NavPriorityBoost} {true}
				ChatExpr {`/ub follow `+$capturegroup_name}
				DoExpr {@CCLeader=$capturegroup_name}
				DoExpr {@CCStay=false}
				SetState {Idle}

	~~ Handle `#action follow` for person who issued command
	IF:	All
			Expr {(follow)#getvar[capturegroup_actiontext]}
			Expr {$capturegroup_name==false}
		DO:	DoAll
				EmbedNav Empty {[None]}
				DoExpr {@CCLeader=$CHARACTER_NAME}
				DoExpr {@CCStay=false}
				SetState {Idle}

	~~ Handle `#action contracts`
	IF: Expr {(contracts)#getvar[capturegroup_actiontext]}	
		DO:	SetState {ReadContracts}

	~~ Handle `#action update`
	IF: Expr {(update)#getvar[capturegroup_actiontext]}
		DO: Chat {/vt meta load CheCommand}

	~~ Handle `#action pack`
	IF: Expr {(pack)#getvar[capturegroup_actiontext]}
		DO: DoAll
				Chat {/mt autopack}
				SetState {Idle}

	~~ Handle `#action mule`
	IF: Expr {(mule)#getvar[capturegroup_actiontext]}
		DO: DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSort`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandHandoffSort`]}
				SetState {CallMeta}

	~~ Handle `#action portal`
	IF: Expr {(portal)#getvar[capturegroup_actiontext]}
		DO: SetState {UsePortal}

	~~ Handle `#action quit`
	IF: Expr {(quit)#getvar[capturegroup_actiontext]}
		DO: ChatExpr {`/ub quit`}

	~~ Handle `#action npc`
	IF: Expr {(npc)#getvar[capturegroup_actiontext]}
		DO: SetState {UseNPC}

	~~ Handle `#action buff`
	IF: Expr {(buff)#getvar[capturegroup_actiontext]}
		DO: DoAll
				SetOpt {EnableBuffing} {True}
				Chat {/vt forcebuff}
				SetState {Idle}

	~~ Handle `#action peace`
	IF: Expr {(peace)#getvar[capturegroup_actiontext]}
		DO: DoAll
				DoExpr {setcombatstate[peace]}
				SetState {Idle}

	~~ Handle `#action vendor`
	IF: Expr {(vendor)#getvar[capturegroup_actiontext]}
		DO: SetState {UseVendor}

	~~ Handle no match for actiontext
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching action for #action`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleNavigation} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_navdestination]}
		DO: DoAll
				DoExpr {echo[`#navto aerlinthe: Navigate to Aerlinthe (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto aphus lassel: Navigate to Aphus Lassel (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto asherons castle: Navigate to Asheron's Castle`, $COLOR_INFO]}
				DoExpr {echo[`#navto bur: Navigate to Bur (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto candeth: Navigate to Candeth Keep (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto colosseum: Navigate to Colosseum (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto comps: Navigate to Haven and purchase comps`, $COLOR_INFO]}
				DoExpr {echo[`#navto couch: Navigate to Haven and sit on the couch`, $COLOR_INFO]}
				DoExpr {echo[`#navto frozen valley: Navigate to Frozen Valley (requires flagging)`, $COLOR_INFO]}
				DoExpr {echo[`#navto facility hub: Navigate to Facility Hub (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto haven buffs: Navigate to Haven and use all buffing items`, $COLOR_INFO]}
				DoExpr {echo[`#navto hoshino: Navigate to Hoshino tent (requires flagging)`, $COLOR_INFO]}
				DoExpr {echo[`#navto gear knight: Navigate to Gear Knights (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto glenden wood: Navigate to Glenden Wood (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto graveyard: Navigate to Graveyard (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto mount lethe: Navigate to Mount Lethe (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto neftet: Navigate to Neftet (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto singularity caul: Navigate to Singularity Caul (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto rynthid: Navigate to Rynthid (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto sanctuary: Navigate to Sanctuary (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto secondary: Navigate to Secondary Portal Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto ulgrims: Navigate to Ulgrim's Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto lifestone: Navigate to Lifestone (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto lifestone recall: Navigate to Lifestone Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto primary: Navigate to Primary Portal Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto portal recall: Navigate to Portal Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`Town Network (Annex):`, $COLOR_INFO]}
				DoExpr {echo[`#navto ahurenga: Navigate to Ahurenga`, $COLOR_INFO]}
				DoExpr {echo[`#navto bluespire: Navigate to Bluespire`, $COLOR_INFO]}
				DoExpr {echo[`#navto danbys outpost: Navigate to Danby's Outpost`, $COLOR_INFO]}
				DoExpr {echo[`#navto eastwatch: Navigate to Eastwatch`, $COLOR_INFO]}
				DoExpr {echo[`#navto fiun outpost: Navigate to Fiun Outpost`, $COLOR_INFO]}
				DoExpr {echo[`#navto greenspire: Navigate to Greenspire`, $COLOR_INFO]}
				DoExpr {echo[`#navto linvak tukal: Navigate to Linvak Tukal`, $COLOR_INFO]}
				DoExpr {echo[`#navto neydisa castle: Navigate to Neydisa Castle`, $COLOR_INFO]}
				DoExpr {echo[`#navto oolutungas refuge: Navigate to Oolutanga's Refuge`, $COLOR_INFO]}
				DoExpr {echo[`#navto redspire: Navigate to Redspire`, $COLOR_INFO]}
				DoExpr {echo[`#navto sanamar: Navigate to Sanamar`, $COLOR_INFO]}
				DoExpr {echo[`#navto silyun: Navigate to Silyun`, $COLOR_INFO]}
				DoExpr {echo[`#navto timaru: Navigate to Timaru`, $COLOR_INFO]}
				DoExpr {echo[`#navto westwatch: Navigate to Westwatch`, $COLOR_INFO]}
				DoExpr {echo[`Town Network (Sho):`, $COLOR_INFO]}
				DoExpr {echo[`#navto baishi: Navigate to Baishi`, $COLOR_INFO]}
				DoExpr {echo[`#navto freehold: Navigate to Freehold`, $COLOR_INFO]}
				DoExpr {echo[`#navto hebian-to: Navigate to Hebian-To`, $COLOR_INFO]}
				DoExpr {echo[`#navto kara: Navigate to Kara`, $COLOR_INFO]}
				DoExpr {echo[`#navto kryst: Navigate to Kryst`, $COLOR_INFO]}
				DoExpr {echo[`#navto lin: Navigate to Lin`, $COLOR_INFO]}
				DoExpr {echo[`#navto mayoi: Navigate to Mayoi`, $COLOR_INFO]}
				DoExpr {echo[`#navto nanto: Navigate to Nanto`, $COLOR_INFO]}
				DoExpr {echo[`#navto sawato: Navigate to Sawato`, $COLOR_INFO]}
				DoExpr {echo[`#navto shoushi: Navigate to Shoushi`, $COLOR_INFO]}
				DoExpr {echo[`#navto tou-tou: Navigate to Tou-Tou`, $COLOR_INFO]}
				DoExpr {echo[`#navto yanshi: Navigate to Yanshi`, $COLOR_INFO]}
				DoExpr {echo[`Town Network (Gharu'ndim):`, $COLOR_INFO]}
				DoExpr {echo[`#navto al-arqas: Navigate to Al-Arqas`, $COLOR_INFO]}
				DoExpr {echo[`#navto al-jalima: Navigate to Al-Jalima`, $COLOR_INFO]}
				DoExpr {echo[`#navto khayyaban: Navigate to Khayyaban`, $COLOR_INFO]}
				DoExpr {echo[`#navto qalabar: Navigate to Qalaba'r`, $COLOR_INFO]}
				DoExpr {echo[`#navto samsur: Navigate to Samsur`, $COLOR_INFO]}
				DoExpr {echo[`#navto tufa: Navigate to Tufa`, $COLOR_INFO]}
				DoExpr {echo[`#navto uziz: Navigate to Uziz`, $COLOR_INFO]}
				DoExpr {echo[`#navto xarabydun: Navigate to Xarabydun`, $COLOR_INFO]}
				DoExpr {echo[`#navto yaraq: Navigate to Yaraq`, $COLOR_INFO]}
				DoExpr {echo[`#navto zaikhal: Navigate to Zaikhal`, $COLOR_INFO]}
				DoExpr {echo[`Town Network (Aluvian):`, $COLOR_INFO]}
				DoExpr {echo[`#navto arwic: Navigate to Arwic`, $COLOR_INFO]}
				DoExpr {echo[`#navto cragstone: Navigate to Cragstone`, $COLOR_INFO]}
				DoExpr {echo[`#navto dryreach: Navigate to Dryreach`, $COLOR_INFO]}
				DoExpr {echo[`#navto eastham: Navigate to Eastham`, $COLOR_INFO]}
				DoExpr {echo[`#navto fort tethana: Navigate to Fort Tethana`, $COLOR_INFO]}
				DoExpr {echo[`#navto glenden wood: Navigate to Glenden Wood`, $COLOR_INFO]}
				DoExpr {echo[`#navto holtburg: Navigate to Holtburg`, $COLOR_INFO]}
				DoExpr {echo[`#navto lytelthorpe: Navigate to Lytelthorpe`, $COLOR_INFO]}
				DoExpr {echo[`#navto plateau village: Navigate to Plateau Village`, $COLOR_INFO]}
				DoExpr {echo[`#navto rithwic: Navigate to Rithwic`, $COLOR_INFO]}
				DoExpr {echo[`#navto stonehold: Navigate to Stonehold`, $COLOR_INFO]}

				SetState {Idle}

	~~ Handle `#navto comps`
	IF: Expr {(comps)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavRecomp`]}
				SetState {CallMeta}

	~~ Handle `#navto haven buffs`
	IF: Expr {(haven buffs)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavHavenBuffs`]}
				SetState {CallMeta}

	~~ Handle `#navto colosseum`
	IF: Expr {(colosseum)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {$CCRecallSpell=4213} ~~ Colosseum Recall
				SetState {HandleRecall}

	~~ Handle `#navto facility hub`
	IF: Expr {(facility hub)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=5175} ~~ Facility Hub Recall
				SetState {HandleRecall}

	~~ Handle `#navto glenden wood`
	IF: Expr {(glenden wood)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=3865} ~~ Glenden Wood Recall
				SetState {HandleRecall}

	~~ Handle `#navto ulgrims`
	IF: Expr {(ulgrims)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2941} ~~ Ulgrim's Recall
				SetState {HandleRecall}

	~~ Handle `#navto candeth`
	IF: Expr {(candeth)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=4214} ~~ Candeth's Keep Recall
				SetState {HandleRecall}

	~~ Handle `#navto bur`
	IF: Expr {(bur)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=4084} ~~ Bur Recall
				SetState {HandleRecall}

	~~ Handle `#navto mount lethe`
	IF: Expr {(mount lethe)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2813} ~~ Mount Lethe Recall
				SetState {HandleRecall}

	~~ Handle `#navto couch`
	IF: Expr {(couch)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavChair`]}
				SetState {CallMeta}

	~~ Handle `#navto asheron castle`
	IF: Expr {(asherons castle)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavPortalspaceActivator`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavPortalspaceActivator`, dictcreate[`destination`, `AsheronsCastle`]]}
				SetState {CallMeta}

	~~ Handle `#navto frozen valley`
	IF: Expr {(frozen valley)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavPortalspaceActivator`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavPortalspaceActivator`, dictcreate[`destination`, `FrozenValley`]]}
				SetState {CallMeta}

	~~ Handle `#navto hoshino`
	IF: Expr {(hoshino)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavPortalspaceActivator`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavPortalspaceActivator`, dictcreate[`destination`, `Hoshino`]]}
				SetState {CallMeta}

	~~ Handle `#navto graveyard`
	IF: Expr {(graveyard)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {$CCRecallSpell=4128} ~~ Call of the Mhoire Forge
				SetState {HandleRecall}

	~~ Handle `#navto neftet`
	IF: Expr {(neftet)#getvar[capturegroup_navdestination]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavNeftet`]}
				SetState {CallMeta}

	~~ Handle `#navto singularity caul`
	IF: Expr {(singularity caul)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2943} ~~ Recall to the Singularity Caul
				SetState {HandleRecall}

	~~ Handle `#navto rynthid`
	IF: Expr {(rynthid)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=6150} ~~ Rynthid Recall
				SetState {HandleRecall}

	~~ Handle `#navto gearknight`
	IF: Expr {(gear knight)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=5330} ~~ Gear Knight Invasion Area Camp Recall
				SetState {HandleRecall}

	~~ Handle `#navto aphus lassel`
	IF: Expr {(aphus lassel)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2931} ~~ Recall Aphus Lassel
				SetState {HandleRecall}

	~~ Handle `#navto aerlinthe`
	IF: Expr {$capturegroup_navdestination==`aerlinthe`}  ~~ Prevent aerlinthe from eating Lin destination
		DO:	DoAll
				DoExpr {$CCRecallSpell=2041} ~~ Aerlinthe Recall
				SetState {HandleRecall}

	~~ Handle `#navto sanctuary`
	IF: Expr {(sanctuary)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2023} ~~ Recall Sanctuary
				SetState {HandleRecall}

	~~ Handle `#navto gear knight`
	IF: Expr {(gear knight)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=5330} ~~ Gear Knight Invasion Area Camp Recall
				SetState {HandleRecall}

	~~ Handle `#navto lifestone`
	IF: Expr {(lifestone)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=1636} ~~ Lifestone Sending
				SetState {HandleRecall}

	~~ Handle `#navto lifestone recall`
	IF: Expr {(lifestone recall)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=1635} ~~ Lifestone recall
				SetState {HandleRecall}

	~~ Handle `#navto portal recall`
	IF: Expr {(portal recall)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2645} ~~ Portal Recall
				SetState {HandleRecall}

	~~ Handle `#navto primary`
	IF: Expr {(primary)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=48} ~~ Primary Portal Recall
				SetState {HandleRecall}

	~~ Handle `#navto secondary`
	IF: Expr {(secondary)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2647} ~~ Secondary Portal Recall
				SetState {HandleRecall}



	~~ Annex

	~~ Handle `#navto ahurenga`
	IF: Expr {(ahurenga)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Ahurenga`]]}
				SetState {CallMeta}

	~~ Handle `#navto bluespire`
	IF: Expr {(bluespire)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Bluespire`]]}
				SetState {CallMeta}

	~~ Handle `#navto danbys outpost`
	IF: Expr {(danbys outpost)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Danby's Outpost`]]}
				SetState {CallMeta}

	~~ Handle `#navto eastwatch`
	IF: Expr {(eastwatch)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Eastwatch`]]}
				SetState {CallMeta}

	~~ Handle `#navto fiun outpost`
	IF: Expr {(fiun outpost)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Fiun Outpost`]]}
				SetState {CallMeta}

	~~ Handle `#navto greenspire`
	IF: Expr {(greenspire)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Greenspire`]]}
				SetState {CallMeta}

	~~ Handle `#navto linvak tukal`
	IF: Expr {$capturegroup_navdestination==`linvak tukal`}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Linvak Tukal`]]}
				SetState {CallMeta}

	~~ Handle `#navto neydisa castle`
	IF: Expr {(neydisa castle)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Neydisa Castle`]]}
				SetState {CallMeta}

	~~ Handle `#navto oolutangas refuge`
	IF: Expr {(oolutangas refuge)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Oolutanga's Refuge`]]}
				SetState {CallMeta}

	~~ Handle `#navto redspire`
	IF: Expr {(redspire)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Redspire`]]}
				SetState {CallMeta}

	~~ Handle `#navto sanamar`
	IF: Expr {(sanamar)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Sanamar`]]}
				SetState {CallMeta}

	~~ Handle `#navto silyun`
	IF: Expr {(silyun)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Silyun`]]}
				SetState {CallMeta}

	~~ Handle `#navto timaru`
	IF: Expr {(timaru)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Timaru`]]}
				SetState {CallMeta}

	~~ Handle `#navto westwatch`
	IF: Expr {(westwatch)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Westwatch`]]}
				SetState {CallMeta}

	~~ Sho

	~~ Handle `#navto baishi`
	IF: Expr {(baishi)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Baishi`]]}
				SetState {CallMeta}

	~~ Handle `#navto freehold`
	IF: Expr {(freehold)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Freehold`]]}
				SetState {CallMeta}

	~~ Handle `#navto hebian-to`
	IF: Expr {(hebian-to)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Hebian-To`]]}
				SetState {CallMeta}

	~~ Handle `#navto kara`
	IF: Expr {(kara)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Kara`]]}
				SetState {CallMeta}

	~~ Handle `#navto kryst`
	IF: Expr {(kryst)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Kryst`]]}
				SetState {CallMeta}

	~~ Handle `#navto lin`
	IF: Expr {(lin)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Lin`]]}
				SetState {CallMeta}

	~~ Handle `#navto mayoi`
	IF: Expr {(mayoi)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Mayoi`]]}
				SetState {CallMeta}

	~~ Handle `#navto nanto`
	IF: Expr {(nanto)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Nanto`]]}
				SetState {CallMeta}

	~~ Handle `#navto sawato`
	IF: Expr {(sawato)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Sawato`]]}
				SetState {CallMeta}

	~~ Handle `#navto shoushi`
	IF: Expr {(shoushi)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Shoushi`]]}
				SetState {CallMeta}

	~~ Handle `#navto tou-tou`
	IF: Expr {(tou-tou)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Tou-Tou`]]}
				SetState {CallMeta}

	~~ Handle `#navto yanshi`
	IF: Expr {(yanshi)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Yanshi`]]}
				SetState {CallMeta}


	~~ Gharu


	~~ Handle `#navto al-arqas`
	IF: Expr {(al-arqas)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Al-Arqas`]]}
				SetState {CallMeta}

	~~ Handle `#navto al-jalima`
	IF: Expr {(al-jalima)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Al-Jalima`]]}
				SetState {CallMeta}

	~~ Handle `#navto khayyaban`
	IF: Expr {(khayyaban)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Khayyaban`]]}
				SetState {CallMeta}

	~~ Handle `#navto qalabar`
	IF: Expr {(qalabar)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Qalaba'r`]]}
				SetState {CallMeta}

	~~ Handle `#navto samsur`
	IF: Expr {(samsur)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Samsur`]]}
				SetState {CallMeta}

	~~ Handle `#navto tufa`
	IF: Expr {(tufa)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Tufa`]]}
				SetState {CallMeta}

	~~ Handle `#navto uziz`
	IF: Expr {(uziz)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Uziz`]]}
				SetState {CallMeta}

	~~ Handle `#navto xarabydun`
	IF: Expr {(xarabydun)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Xarabydun`]]}
				SetState {CallMeta}

	~~ Handle `#navto yaraq`
	IF: Expr {(yaraq)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Yaraq`]]}
				SetState {CallMeta}

	~~ Handle `#navto zaikhal`
	IF: Expr {(zaikhal)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Zaikhal`]]}
				SetState {CallMeta}


	~~ Aluvian


	~~ Handle `#navto arwic`
	IF: Expr {(arwic)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Arwic`]]}
				SetState {CallMeta}

	~~ Handle `#navto cragstone`
	IF: Expr {(cragstone)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Cragstone`]]}
				SetState {CallMeta}

	~~ Handle `#navto dryreach`
	IF: Expr {(dryreach)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Dryreach`]]}
				SetState {CallMeta}

	~~ Handle `#navto eastham`
	IF: Expr {(eastham)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Eastham`]]}
				SetState {CallMeta}

	~~ Handle `#navto fort tethana`
	IF: Expr {(fort tethana)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Fort Tethana`]]}
				SetState {CallMeta}

	~~ Handle `#navto glenden wood`
	IF: Expr {(glenden wood)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Glenden Wood`]]}
				SetState {CallMeta}

	~~ Handle `#navto holtburg`
	IF: Expr {(holtburg)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Holtburg`]]}
				SetState {CallMeta}

	~~ Handle `#navto lytelthorpe`
	IF: Expr {(lytelthorpe)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Lytelthorpe`]]}
				SetState {CallMeta}

	~~ Handle `#navto plateau village`
	IF: Expr {(plateau village)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Plateau Village`]]}
				SetState {CallMeta}

	~~ Handle `#navto rithwic`
	IF: Expr {(rithwic)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Rithwic`]]}
				SetState {CallMeta}

	~~ Handle `#navto stonehold`
	IF: Expr {(stonehold)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Stonehold`]]}
				SetState {CallMeta}


	~~ Handle no match for navdestination
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching destination for #navto`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleRoute} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ No routes found, show warning
	IF: Expr {listcount[listfilter[dictkeys[$CCRoutes], `cstrf[getplayerlandcell[], \`X8\`]==$1`]]==0}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching routes found for `+cstrf[getplayerlandcell[], `X8`], $COLOR_WARN]}
				SetState {Idle}

	~~ Route found, load route and start navigation
	IF: Expr {listcount[listfilter[dictkeys[$CCRoutes], `cstrf[getplayerlandcell[], \`X8\`]==$1`]]>0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Loading route: \`+dictgetitem[$CCRoutes, cstrf[getplayerlandcell[], \`X8\`]]]`, `false`]}
				ChatExpr {`/vt nav load `+dictgetitem[$CCRoutes, cstrf[getplayerlandcell[], `X8`]]}
				SetOpt {EnableNav} {True}
				SetOpt {NavPriorityBoost} {False}
				SetState {Idle}

~~ }


STATE: {HandleProfile} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#profile help`
	IF: Expr {(help)#getvar[capturegroup_profiletext]}
		DO: DoAll
				DoExpr {echo[`#profile: Loads the profile associated with the landcell`, $COLOR_INFO]}
				DoExpr {echo[`#profile <Profile Nickname>: Loads the profile on all characters`, $COLOR_INFO]}
				DoExpr {echo[`#profile add <Profile Nickname> <Profile Filename>: Adds the profile to the saved profiles list`, $COLOR_INFO]}
				DoExpr {echo[`#profile addlandcell <Profile Name>: Adds the profile with the current landcell to the auto load profile list`, $COLOR_INFO]}
				DoExpr {echo[`#profile landcell: Shows the current profile for the landcell`, $COLOR_INFO]}
				DoExpr {echo[`#profile list: Lists all saved profiles`, $COLOR_INFO]}
				DoExpr {echo[`#profile load <Profile Nickname>: Loads the profile on all characters`, $COLOR_INFO]}
				SetState {Idle}

	~~ Warn if `#profile landcell` has no entry
	IF: All
			Expr {(landcell)#getvar[capturegroup_profiletext]}
			Expr {listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]==-1}
		DO: DoAll
				DoExpr {echo[`[WARN] No profile found for landcell `+cstrf[getplayerlandcell[], `X8`], $COLOR_WARN]}
				SetState {Idle}

	~~ Show `#profile landcell` value
	IF: All
			Expr {(landcell)#getvar[capturegroup_profiletext]}
			Expr {listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]!=-1}
		DO: DoAll
				DoExpr {$id=listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]}
				DoExpr {echo[cstrf[getplayerlandcell[], `X8`]+` => `+listgetitem[@CCProfileLandcellValues, $id], $COLOR_INFO]}
				SetState {Idle}

	~~ Show `#profile list` values
	IF: Expr {(list)#getvar[capturegroup_profiletext]}
		DO: DoAll
				DoExpr {listmap[@CCProfileKeys, `echo[$1+\` => \`+listgetitem[@CCProfileValues, $0], $COLOR_INFO]`]}
				SetState {Idle}


	~~ Handle no match for profiletext
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching argument for #profile`, $COLOR_WARN]}
				SetState {Idle}

~~ }

STATE: {ProfileAdd} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Add a profile
	IF: Always
		DO: DoAll
				DoExpr {listadd[@CCProfileKeys, $capturegroup_profilename]}
				DoExpr {listadd[@CCProfileValues, $capturegroup_profilevalue]}
				DoExpr {echo[`Added `+$capturegroup_profilename+` => `+$capturegroup_profilevalue, $COLOR_INFO]}
				SetState {Idle}

~~ }


STATE: {ProfileLoad} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Warn if no profile found
	IF: Expr {listindexof[@CCProfileKeys, $capturegroup_profilename]==-1}
		DO: DoAll
				DoExpr {echo[`[WARN] No profile found`, $COLOR_WARN]}
				SetState {Idle}

	~~ load profile
	IF: Expr {listindexof[@CCProfileKeys, $capturegroup_profilename]!=-1}
		DO: DoAll
				DoExpr {$id=listindexof[@CCProfileKeys, $capturegroup_profilename]}
				ChatExpr {`/vt settings loadchar `+listgetitem[@CCProfileValues, $id]}
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Loaded profile \`+listgetitem[@CCProfileValues, $id]]`, `false`]}
				SetState {Idle}

~~ }


STATE: {ProfileAddLandcell} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Add a profile for a landcell
	IF: Always
		DO: DoAll
				DoExpr {listadd[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]}
				DoExpr {listadd[@CCProfileLandcellValues, $capturegroup_profilename]}
				DoExpr {echo[`Added `+cstrf[getplayerlandcell[], `X8`]+` => `+$capturegroup_profilename, $COLOR_INFO]}
				SetState {Idle}

~~ }


STATE: {AutoloadProfile} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Warn if landcell has no entry
	IF: Expr {listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]==-1}
		DO: DoAll
				DoExpr {echo[`[WARN] No profile found for landcell `+cstrf[getplayerlandcell[], `X8`], $COLOR_WARN]}
				SetState {Idle}

	~~ Load profile for landcell
	IF: Expr {listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]!=-1}
		DO: DoAll
				DoExpr {$id=listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]}
				DoExpr {$nickname=listgetitem[@CCProfileLandcellValues, $id]}
				DoExpr {$nid=listindexof[@CCProfileKeys, $nickname]}
				ChatExpr {`/vt settings loadchar `+listgetitem[@CCProfileValues, $nid]}
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Loaded profile \`+listgetitem[@CCProfileValues, $nid]]`, `false`]}
				SetState {Idle}

~~ }


STATE: {HandleKilltask} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_ktaction]}
		DO: DoAll
				DoExpr {echo[`#killtask all: Begins all killtask loops`, $COLOR_INFO]}
				DoExpr {echo[`#killtask check: Checks remaining kill tasks (NOT IMPLEMENTED)`, $COLOR_INFO]}
				DoExpr {echo[`#killtask frozen valley: Begins killtask loop in Frozen Valley`, $COLOR_INFO]}
				DoExpr {echo[`#killtask neftet: Begins killtask loop in Neftet`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#killtask check`
	IF: Expr {(check)#getvar[capturegroup_ktaction]}
		DO: DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskCheck`]}
				SetState {CallMeta}

	~~ Handle `#killtask all`
	IF: Expr {(all)#getvar[capturegroup_ktaction]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagNeftet`]}
				SetState {CallMeta}

	~~ Handle `#killtask frozen valley`
	IF: Expr {(frozen valley)#getvar[capturegroup_ktaction]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagFrozenValley`]}
				SetState {CallMeta}

	~~ Handle `#killtask neftet`
	IF: Expr {(neftet)#getvar[capturegroup_ktaction]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagNeftet`]}
				SetState {CallMeta}

	~~ Handle no match for navdestination
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching destination for #killtask`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleFlagging} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_flagaction]}
		DO: DoAll
				DoExpr {echo[`#flag frozen valley: Flags with all NPCs in Frozen Valley`, $COLOR_INFO]}
				DoExpr {echo[`#flag neftet: Flags with all NPCs in Neftet`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#flag frozen valley`
	IF: Expr {(frozen valley)#getvar[capturegroup_flagaction]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagFrozenValley`]}
				SetState {CallMeta}

	~~ Handle `#flag neftet`
	IF: Expr {(neftet)#getvar[capturegroup_flagaction]}	
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagNeftet`]}
				SetState {CallMeta}

	~~ Handle no match for flagaction
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching action for #flag`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleLootingInfo} ~~ {

	~~ IF: Expr {(auto)#getvar[capturegroup_loottext]}
	~~ 	DO: SetState {AutoLoot}

	IF: Expr {(help)#getvar[capturegroup_loottext]}
		DO: DoAll
				DoExpr {echo[`#loot: Automatically loot items from corpses for many legendary quests.`, $COLOR_INFO]}
				DoExpr {echo[`#loot <item name> from <corpse name>: Loot the item from a corpse on all characters.`, $COLOR_INFO]}
				SetState {Idle}

~~ }


STATE: {HandleLooting} ~~ {

	IF: Always
		DO: DoAll
				DoExpr {$LootCorpseItem=$capturegroup_item}
				DoExpr {$LootCorpseName=$capturegroup_corpse}
				SetState {Loot}

~~ }


STATE: {HandleFace} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#check help`
	IF: Expr {(help)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {echo[`#face north`, $COLOR_INFO]}
				DoExpr {echo[`#face south`, $COLOR_INFO]}
				DoExpr {echo[`#face east`, $COLOR_INFO]}
				DoExpr {echo[`#face west`, $COLOR_INFO]}
				DoExpr {echo[`#face northeast`, $COLOR_INFO]}
				DoExpr {echo[`#face northwest`, $COLOR_INFO]}
				DoExpr {echo[`#face southeast`, $COLOR_INFO]}
				DoExpr {echo[`#face southwest`, $COLOR_INFO]}
				DoExpr {echo[`#face <heading>: Face in a specific heading`, $COLOR_INFO]}
				SetState {Idle}

	IF: Expr {(north)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`0`}
				SetState {Face}

	IF: Expr {(south)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`180`}
				SetState {Face}

	IF: Expr {(east)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`90`}
				SetState {Face}

	IF: Expr {(west)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`270`}
				SetState {Face}

	IF: Expr {(northeast)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`45`}
				SetState {Face}

	IF: Expr {(northwest)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`315`}
				SetState {Face}

	IF: Expr {(southeast)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`135`}
				SetState {Face}

	IF: Expr {(southwest)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`225`}
				SetState {Face}

	IF: Always
		DO: DoAll
				DoExpr {$direction=$capturegroup_facedirection}
				SetState {Face}

~~ }


STATE: {Face} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Face}

	IF:	ChatMatch {^You think, "Turning Success"}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished turning\`]`, `false`]}
				DoExpr {clearvar[direction]}
				CallState {EnableOptions} {Idle}

	IF:	ChatMatch {^You think, "Turning failed"}
		DO: SetState {Face}

	IF: Always
		DO: ChatExpr {`/ub face `+$direction}

~~ }


STATE: {HandleJumping} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#jump tap`
	IF: Expr {(tap)#getvar[capturegroup_jumptext]}
		DO: DoAll
				DoExpr {$Jumptext=`sw 250`}
				SetState {Jump}

	~~ Handle `#jump <jumptext>`
	IF: Always
		DO: DoAll
				DoExpr {$Jumptext=$capturegroup_jumptext}
				SetState {Jump}

~~ }


STATE: {Jump} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Jump}

	~~ Try jumping
	IF: Always
		DO: ChatExpr {`/ub jump`+$Jumptext}

	~~ Jump success
	IF:	ChatMatch {^You think, "Jumper Success"}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished jumping\`]`, `false`]}
				CallState {EnableOptions} {Idle}

	~~ Jump failure
	IF:	ChatMatch {^You think, "You have failed to jump too many times}
		DO:	SetState {Jump}

~~ }


STATE: {HandlePickup} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Always
		DO: DoAll
				DoExpr {$item=$capturegroup_itemtext}
				SetState {Pickup}

~~ }


STATE: {Pickup} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {clearvar[itemCount]}
				DoExpr {clearvar[item]}
				DoExpr {clearvar[hasNearbyItem]}
				SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Pickup}

	~~ Set the amount of items you have
	IF: Expr {testvar[itemCount]==false}
		DO: DoExpr {$itemCount=getitemcountininventorybynamerx[$item]}

	~~ Handle no items nearby
	IF: All
			Expr {testvar[hasNearbyItem]==false]}
			Expr {listcount[wobjectfindalllandscapebynamerx[$item]]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No \`+$item+\` nearby\`]`, `false`]}
				CallState {EnableOptions} {Idle}

	~~ Stop picking up if your items are above the initial value or ChatMatch
	IF: Any
			Expr {getitemcountininventorybynamerx[$item]>$itemCount}
			ChatMatch {You have solved}
			ChatMatch {You cannot pick up more than}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Picked up \`+$item]`, `false`]}
				DoExpr {clearvar[itemCount]}
				DoExpr {clearvar[item]}
				DoExpr {clearvar[hasNearbyItem]}
				CallState {EnableOptions} {Idle}

	~~ Pickup the item from the landscape
	IF: All
			Expr {listcount[wobjectfindalllandscapebynamerx[$item]]>0}
			Expr {getitemcountininventorybynamerx[$item]==$itemCount} 
		DO: DoAll
				DoExpr {actiontryuseitem[listpop[wobjectfindalllandscapebynamerx[$item], 0]]}
				DoExpr {setvar[hasNearbyItem, true]}
				SetState {Pickup}

~~ }


STATE: {HandleGive} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Always
		DO: DoAll
				DoExpr {$item=$capturegroup_itemtext}
				DoExpr {$name=$capturegroup_giveto}
				SetState {Give}

~~ }


STATE: {AutoGive} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ No NPC nearby with the Autogive name
	IF: Not Expr {dicthaskey[$AUTOGIVE_PROFILE, wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]]}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No autogive profile for \`+wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]]`, `false`]}
				SetState {Idle}

	~~ Found NPC hand off to Give
	IF: Expr {dicthaskey[$AUTOGIVE_PROFILE, wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]]}
		DO: DoAll
				DoExpr {$name=wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]}
				DoExpr {$item=dictgetitem[$AUTOGIVE_PROFILE, $name]}
				SetState {Give}

~~ }


STATE: {Give} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Give}

	~~ If set equip item before giving
	IF: Expr {@CCEquipOnTurnin!=false} 
		DO: DoAll
				DoExpr {actiontryuseitem[@CCEquipOnTurnin]}

	~~ Successfully handed off item
	IF: Any
			ChatMatch {^You give}
			ChatMatch {^You hand over}
			ChatMatch {^You allow}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Gave \`+$item]`, `false`]}
				CallState {EnableOptions} {Idle}

	~~ Handle $item being a list
	IF: Expr {getobjectinternaltype[$item]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {$hasItems=listfilter[$item, `wobjectfindininventorybynamerx[\`^\`+$1+\`$\`]`]}
				DoExpr {$item=ifthen[listcount[$hasItems]>=1, `listpop[$hasItems, 0]`, `false`]}
				SetState {Give}

	~~ Missing item
	IF: All
			SecsInStateGE 1
			Expr {wobjectfindininventorybynamerx[`^`+$item+`$`]==false}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I do not have \`+$item]`, `false`]}
				CallState {EnableOptions} {Idle}

	~~ Give to nearest Player
	IF: All
			Expr {getobjectinternaltype[wobjectfindininventorybynamerx[`^`+$item+`$`]]==$TYPE_OBJECT}
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$PLAYER, $name]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {actiontrygiveitem[wobjectfindininventorybynamerx[`^`+$item+`$`], wobjectfindnearestbynameandobjectclass[$PLAYER, $name]]}
				SetState {Give}

	~~ Give to nearest NPC
	IF: All
			Expr {getobjectinternaltype[wobjectfindininventorybynamerx[`^`+$item+`$`]]==$TYPE_OBJECT}
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$NPC, $name]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {actiontrygiveitem[wobjectfindininventorybynamerx[`^`+$item+`$`], wobjectfindnearestbynameandobjectclass[$NPC, $name]]}
				SetState {Give}

	~~ Handle no player or NPC with that name nearby
	IF: Expr {wobjectfindnearestbynameandobjectclass[$PLAYER, $name]==false&&wobjectfindnearestbynameandobjectclass[$NPC, $name]==false}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I can't find \`+$name]`, `false`]}
				CallState {EnableOptions} {Idle}

~~ }


STATE: {HandlePass} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Always
		DO: DoExpr {$item=$capturegroup_passtext}

	~~ Handle `#pass` for followers
	IF:	Expr {$capturegroup_name!=false}
		DO:	SetState {PassWait}

	~~ Handle `#pass` for person who issued command
	IF:	Expr {$capturegroup_name==false}
		DO:	SetState {PassGive}

~~ }


STATE: {PassWait} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Use the item when given
	IF: ChatMatch {gives you}
		DO: DoAll
				DoExpr {actiontryuseitem[listgetitem[wobjectfindallinventorybynamerx[$item], 0]]}
				SetState {PassGive}

~~ }


STATE: {PassGive} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Warn if no item found
	IF: All
			Expr {testvar[giving]==false}
			Expr {listcount[wobjectfindallinventorybynamerx[$item]]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I do not have \`+$item]`, `false`]}
				SetState {Idle}

	~~ Pass to next person in the @CCCharacterList
	IF: Expr {listcount[wobjectfindallinventorybynamerx[$item]]>0}
		DO: DoAll
				DoExpr {$sortedCharacters=listsort[@CCCharacterList]} ~~ Sort to ensure all character lists are identical in order
				DoExpr {$currentPos=listindexof[$sortedCharacters, $CHARACTER_NAME]}
				DoExpr {$nextPos=ifthen[$currentPos+1>listcount[$sortedCharacters]-1, `0`, `$currentPos+1`]}
				DoExpr {$nextCharacter=listgetitem[$sortedCharacters, $nextPos]}
				DoExpr {$giving=true}
				DoExpr {actiontrygiveitem[listgetitem[wobjectfindallinventorybynamerx[$item], 0], wobjectfindnearestbynameandobjectclass[$PLAYER, $nextCharacter]]}
				SetState {PassGive}

	~~ Handed off item
	IF: ChatMatch {^You give}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Gave \`+$item]`, `false`]}
				DoExpr {listmap[listcreate[`sortedCharacters`, `currentPos`, `nextPos`, `nextCharacter`, `giving`, `item`], `clearvar[$1]`]}
				SetState {Idle}

~~ }

STATE: {HandleCheck} ~~ {

	~~ TODO: distance

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#check help`
	IF: Expr {(help)#getvar[capturegroup_checktext]}
		DO: DoAll
				DoExpr {echo[`#check buffs: check how much time is left on each characters buffs.`, $COLOR_INFO]}
				DoExpr {echo[`#check luminance: check how much luminance each character has.`, $COLOR_INFO]}
				DoExpr {echo[`#check level: check what level each character is.`, $COLOR_INFO]}
				DoExpr {echo[`#check landblock: check what landblock each character is in.`, $COLOR_INFO]}
				DoExpr {echo[`#check landcell: check what landcell each character is in.`, $COLOR_INFO]}
				DoExpr {echo[`#check settings: check the settings (Toggle Vitals, Buff, Combat, Nav, Loot) of all characters.`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#check buffs`
	IF: Expr {(buffs)#getvar[capturegroup_checktext]}
		DO: DoAll
				DoExpr {$total_seconds=getspellexpirationbyname[@CCCheckBuffsSpell]}
				DoExpr {$hours=floor[$total_seconds/3600]}
				DoExpr {$remaining_seconds=$total_seconds%3600}
				DoExpr {$minutes=floor[$remaining_seconds/60]}
				DoExpr {$seconds=$remaining_seconds%60}
				ChatExpr {`/f Buffs: `+$hours+` hours, `+$minutes+` minutes, `+$seconds+` seconds`}
				SetState {Idle}

	~~ Handle `#check luminance`
	IF: Expr {(luminance)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/f Luminance: `+cstrf[getcharquadprop[6], `N0`]}
				SetState {Idle}

	~~ Handle `#check level`
	IF: Expr {(level)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/f Level: `+getcharintprop[25]}
				SetState {Idle}

	~~ Handle `#check landblock`
	IF: Expr {(landblock)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/f Landblock: `+hexstr[getplayerlandblock[]]}
				SetState {Idle}

	~~ Handle `#check landcell`
	IF: Expr {(landcell)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/f Landblock: `+hexstr[getplayerlandcell[]]}
				SetState {Idle}

	~~ Handle `#check settings`
	IF: Expr {(settings)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/f Toggle Vitals: `+ifthen[@CCVitals, `On`, `Off`]+`, Buff: `+ifthen[vtgetsetting[EnableBuffing], `On`, `Off`]+`, Combat: `+ifthen[vtgetsetting[EnableCombat], `On`, `Off`]+`, Nav: `+ifthen[vtgetsetting[EnableNav], `On`, `Off`]+`, Loot: `+ifthen[vtgetsetting[EnableLooting], `On`, `Off`]}
				SetState {Idle}

	~~ Handle no match for checktext
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching action for #check`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {AutoLoot} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Warn if there are no corpses
	IF: Expr {listcount[wobjectfindalllandscapebyobjectclass[$CORPSE]]==0}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] No corpses found\`, $COLOR_WARN]`, `false`]}
				SetState {Idle}

	~~ Find all corpses with a name in $AUTO_LOOT_CORPSES
	IF: Expr {listcount[wobjectfindalllandscapebyobjectclass[$CORPSE]]>0}
		DO: DoAll
				DoExpr {$foundCorpses=listfilter[wobjectfindalllandscapebyobjectclass[$CORPSE], `listcontains[dictkeys[$AUTO_LOOT_CORPSES], wobjectgetstringprop[$1, $STRING_PROP_NAME]]`]}

	~~ Warn if no corpses found with a name in $AUTO_LOOT_CORPSES
	IF: All
			Expr {listcount[wobjectfindalllandscapebyobjectclass[$CORPSE]]>0}
			Expr {listcount[$foundCorpses]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No auto loot corpses found!\`]`, `false`]}
				DoExpr {clearvar[foundCorpses]}
				SetState {Idle}

	~~ Send the first corpse found to Loot
	IF: All
			Expr {listcount[wobjectfindalllandscapebyobjectclass[$CORPSE]]>0}
			Expr {listcount[$foundCorpses]>0}
		DO: DoAll
				DoExpr {$LootCorpseItem=dictgetitem[$AUTO_LOOT_CORPSES, wobjectgetstringprop[listgetitem[$foundCorpses, 0], $STRING_PROP_NAME]]}
				DoExpr {$LootCorpseName=wobjectgetstringprop[listgetitem[$foundCorpses, 0], $STRING_PROP_NAME]}
				DoExpr {clearvar[foundCorpses]}
				SetState {Loot}

~~ }


STATE: {Loot} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Loot}

	IF: Expr {testvar[CorpseBlacklist]==false}
		DO: DoExpr {$CorpseBlacklist=listcreate[]}

	~~ Find Potential Corpses
	IF: Always
		DO: DoAll
				DoExpr {$allCorpses=wobjectfindalllandscapebynamerx[$LootCorpseName]}
				DoExpr {$nearbyCorpses=listfilter[$allCorpses, `coordinatedistancewithz[wobjectgetphysicscoordinates[$1], getplayercoordinates[]]<=15`]}
				DoExpr {$foundCorpses=listfilter[$nearbyCorpses, `listcontains[$CorpseBlacklist, wobjectgetid[$1]]==false`]}

	~~ Out of corpses
	IF: Expr {listcount[$foundCorpses]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No corpses found with \`+$LootCorpseItem]`, `false`]}
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {LeaderCheck}

	~~ OpenCorpse of first foundCorpse
	IF: Expr {listcount[$foundCorpses]>0}
		DO: DoAll
				DoExpr {$Corpse=listpop[$foundCorpses, 0]}
				SetState {OpenCorpse}

~~ }

STATE: {OpenCorpse} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {LeaderCheck}

	~~ Has an open corpse
	IF: Expr {getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT}
		DO: DoAll
				~~ DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Opened corpse\`, $COLOR_INFO]`, `false`]}
				SetState {LootCorpse}

	~~ Try opening the corpse
	IF: Always
		DO: DoAll
				DoExpr {$actiontryuseitem[$Corpse]}
				SetState {OpenCorpse}

	~~ FIXME: Handle corpse dissappearing
~~ }


STATE: {LootCorpse} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {LeaderCheck}

	~~ IF: Always
	~~ 	DO: DoAll
	~~ 			DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Looting corpse\`, $COLOR_INFO]`, `false`]}

	~~ Count how many of the item is in inventory
	IF: Expr {testvar[ItemCount]==false}
		DO: DoAll
				DoExpr {$ItemCount=getitemcountininventorybynamerx[$LootCorpseItem]}
				DoExpr {`$ItemCount: `+$ItemCount}

	~~ Corpse is not open
	IF: Expr {getobjectinternaltype[wobjectgetopencontainer[]]!=$TYPE_OBJECT}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[WARN] Corpse is not open!\`, $COLOR_WARN]`, `false`]}
				SetState {OpenCorpse}

	~~ Find all wanted items on the corpse
	IF: Expr {getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {$CorpseItems=wobjectfindallbycontainer[wobjectgetopencontainer[]]}
				DoExpr {$CorpseItemsWanted=listfilter[$CorpseItems, `wobjectgetstringprop[$1, $STRING_PROP_NAME]==$LootCorpseItem`]}

	~~ Warn if unable to pickup item
	IF: ChatMatch {You have solved this quest too recently!}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Unable to loot \`+$LootCorpseItem]`, `false`]}
				DoExpr {ifthen[getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT, `actiontryuseitem[wobjectgetopencontainer[]]`, `false`]}  ~~ Close the container
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {CloseCorpse}

	~~ Picked up an item since inventory has increased
	IF: Expr {getitemcountininventorybynamerx[$LootCorpseItem]>$ItemCount}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Looted \`+$LootCorpseItem]`, `false`]}
				DoExpr {ifthen[getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT, `actiontryuseitem[wobjectgetopencontainer[]]`, `false`]}  ~~ Close the container
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {CloseCorpse}

	~~ Warn if no items found on the corpse
	IF: Expr {listcount[$CorpseItemsWanted]==0}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] Did not find the item \`+$LootCorpseItem+\` on \`+$LootCorpseName, $COLOR_WARN]`, `false`]}
				DoExpr {ifthen[getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT, `actiontryuseitem[wobjectgetopencontainer[]]`, `false`]}  ~~ Close the container
				DoExpr {listadd[$CorpseBlacklist, wobjectgetid[$Corpse]]}
				SetState {Loot}

	~~ Pickup item from the corpse
	IF: Expr {listcount[$CorpseItemsWanted]>0}
		DO: DoAll
				DoExpr {$item=listpop[$CorpseItemsWanted, 0]}
				DoExpr {actiontryuseitem[$item]}
				SetState {LootCorpse}

	~~ /ub mexec wobjectgetstringprop[wobjectfindallbycontainer[wobjectgetopencontainer[]]{0}, 1]
	~~ Ghost items in the inventory can be handled by getbusy or setting a timer and waiting

~~ }


STATE: {CloseCorpse} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {LeaderCheck}

	~~ Corpse is closed; finish looting
	IF: Expr {getobjectinternaltype[wobjectgetopencontainer[]]!=$TYPE_OBJECT}
		DO: SetState {LeaderCheck}

	~~ Has an open corpse so try closing it
	IF: Expr {getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {ifthen[getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT, `actiontryuseitem[wobjectgetopencontainer[]]`, `false`]}  ~~ Close the container
				SetState {CloseCorpse}

~~ }


STATE: {UsePortal} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UsePortal}

	~~ No portal within range but there is an NPC nearby
	IF: All
			Expr {isportaling[]==false}
			Expr {getobjectinternaltype[wobjectfindnearestbyobjectclass[$NPC]]==$TYPE_OBJECT} ~~ NPC within range
			Any
				Expr {wobjectfindnearestbyobjectclass[$PORTAL]==false} ~~ No portal detected
				Not Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$PORTAL]], getplayercoordinates[]]<=@CCPortalThreshold} ~~ No portal within threshold
		DO: SetState {UsePortalNPC}

	~~ No portal or NPC within range
	IF: All
			Expr {isportaling[]==false}
			Any
				Expr {wobjectfindnearestbyobjectclass[$PORTAL]==false} ~~ no portal detected
				Not Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$PORTAL]], getplayercoordinates[]]<=@CCPortalThreshold} ~~ no portal within threshold
			Any
				Expr {wobjectfindnearestbyobjectclass[$NPC]==false} ~~ no NPC detected
				Not Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$NPC]], getplayercoordinates[]]<=@CCPortalThreshold} ~~ no NPC within threshold
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No portal within range!\`]`, `false`]}
				SetState {LeaderCheck}

	~~ Warn if you must complete a quest to interact with that portal.
	IF: All
			Expr {isportaling[]==false}
			ChatMatch {You must complete a quest to interact with that portal.}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Unable to use portal!\`]`, `false`]}
				SetState {LeaderCheck}

	~~ Use the Portal
	IF:	Expr {isportaling[]==false}
		DO:	DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$PORTAL]]}
				SetState {UsePortal}

	~~ Finished using portal; reset options to what they originally were
	IF:	Expr {isportaling[]==true}
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished using portal\`]`, `false`]}
				SetState {LeaderCheck}

~~ }


STATE: {UsePortalNPC} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ The NPC does not have data, we need to query for it
	IF: Expr {wobjecthasdata[wobjectfindnearestbyobjectclass[$NPC]]==false}
		DO: DoAll
				DoExpr {wobjectrequestdata[wobjectfindnearestbyobjectclass[$NPC]]}
				SetState {UsePortalNPC}

	~~ No NPC in range with `portal` in description
	IF: All
			Expr {wobjecthasdata[wobjectfindnearestbyobjectclass[$NPC]]==true}
			Not Expr {istrue[wobjectgetstringprop[wobjectfindnearestbyobjectclass[$NPC], $STRING_PROP_DESCRIPTION]#portal]}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No portal within range!\`]`, `false`]}
				SetState {LeaderCheck}

	~~ Use the NPC Portal
	IF:	All
			Expr {isportaling[]==false}
			Expr {wobjecthasdata[wobjectfindnearestbyobjectclass[$NPC]]==true}
			Expr {istrue[wobjectgetstringprop[wobjectfindnearestbyobjectclass[$NPC], $STRING_PROP_DESCRIPTION]#portal]}
		DO:	DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$NPC]]}
				SetState {UsePortalNPC}

	~~ Finished using portal; go to LeaderCheck
	IF:	Expr {isportaling[]==true}
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished using portal\`]`, `false`]}
				SetState {LeaderCheck}

~~ }


STATE: {UseVRPortal} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UseVRPortal}

	~~ Use the VR portal
	IF:	Expr {isportaling[]==false}
		DO:	DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbynameandobjectclass[$NPC, `Viridian Portal`]]}
				SetState {UseVRPortal}

	~~ Finished using portal; go to LeaderCheck
	IF:	Expr {isportaling[]==true}
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished using VR portal\`]`, `false`]}
				SetState {LeaderCheck}

~~ }


STATE: {LeaderCheck} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Warn if commands are issued
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#(?<command>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I cannot listen to commands! I am currently in the state \`+vtgetmetastate[]]`, `false`]}

	~~ Disable all options if other states haven't
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {LeaderCheck}

	~~ If leader go straight to EnableOptions
	IF: Expr {@CCLeader==$CHARACTER_NAME}
		DO: CallState {EnableOptions} {Idle}

	~~ If following re-enable follow when leader is nearby
	IF: All
			Expr {@CCStay==false}
			Expr {@CCLeader!=$CHARACTER_NAME}
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$PLAYER, @CCLeader]]==$TYPE_OBJECT}  ~~ CCLeader WObject exists
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$PLAYER, @CCLeader]], getplayercoordinates[]]<=@CCLeaderCheckDistance}  ~~ CCLeader is nearby
		DO: DoAll
				SetOpt {NavPriorityBoost} {true}
				ChatExpr {`/ub follow `+@CCLeader}

	~~ When leader is nearby leave check
	IF: All
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$PLAYER, @CCLeader]]==$TYPE_OBJECT}  ~~ CCLeader WObject exists
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$PLAYER, @CCLeader]], getplayercoordinates[]]<=@CCLeaderCheckDistance}  ~~ CCLeader is nearby
		DO: CallState {EnableOptions} {Idle}

	~~ Warn if in the check too long
	IF:	SecsInStateGE 15
		DO: DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Waiting for nearby leader for 15 seconds!\`]`, `false`]}

	~~ Disable waiting if longer than the timeout
	IF: SecsInStateGE 30
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Timeout reached waiting for leader! Staying but listening for commands.\`]`, `false`]}
				EmbedNav Empty {[None]}
				DoExpr {@CCStay=true}
				CallState {EnableOptions} {Idle}

~~ }


STATE: {HandleFellow} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_fellowtext]}
		DO: DoAll
				DoExpr {echo[`#fellow add: Add characters by name`, $COLOR_INFO]}
				DoExpr {echo[`#fellow close: Close the fellow`, $COLOR_INFO]}
				DoExpr {echo[`#fellow create: Create a fellow and add all characters in @CCCharacterList`, $COLOR_INFO]}
				DoExpr {echo[`#fellow disband: Disband the fellow`, $COLOR_INFO]}
				DoExpr {echo[`#fellow nearby: Add all characters close to the issuer of the command`, $COLOR_INFO]}
				DoExpr {echo[`#fellow open: Open the fellow`, $COLOR_INFO]}
				DoExpr {echo[`#fellow quit: All characters quit the fellow`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#fellow close` for the leader
	IF: All
			Expr {(close)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==true}
		DO: DoAll
				ChatExpr {`/ub fellow close`}
				SetState {Idle}

	~~ Handle `#fellow close` for followers
	IF: All
			Expr {(close)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==false}
		DO:	SetState {Idle}

	~~ Handle `#fellow create` for the character who issued the command
	IF: All
			Expr {(create)#getvar[capturegroup_fellowtext]}
			Expr {$capturegroup_name==false}
		DO:	SetState {FellowCreate}

	~~ Handle `#fellow create` for followers
	IF: All
			Expr {(create)#getvar[capturegroup_fellowtext]}
			Expr {$capturegroup_name!=false}
		DO:	SetState {Idle}

	~~ Handle `#fellow disband` for leader
	IF: All
			Expr {(disband)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==true}
		DO:	DoAll
				ChatExpr {`/ub fellow disband`}
				SetState {Idle}

	~~ Handle `#fellow disband` for followers
	IF: All
			Expr {(disband)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==false}
		DO:	SetState {Idle}

	~~ Handle `#fellow nearby` for character who issued the command
	IF: All
			Expr {(nearby)#getvar[capturegroup_fellowtext]}
			Expr {$capturegroup_name==false}
		DO:	SetState {FellowNearby}

	~~ Handle `#fellow nearby` for followers
	IF: All
			Expr {(nearby)#getvar[capturegroup_fellowtext]}
			Expr {$capturegroup_name!=false}
		DO:	SetState {Idle}

	~~ Handle `#fellow open` for the leader
	IF: All
			Expr {(open)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==true}
		DO: DoAll
				ChatExpr {`/ub fellow open`}
				SetState {Idle}

	~~ Handle `#fellow open` for followers
	IF: All
			Expr {(open)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==false}
		DO:	SetState {Idle}

	~~ Handle `#fellow quit`
	IF: Expr {(quit)#getvar[capturegroup_fellowtext]}
		DO:	DoAll
				ChatExpr {`/ub fellow quit`}
				SetState {Idle}

	~~ Handle no match for actiontext
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching parameter for #fellow`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {FellowCreate} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Create the fellow
	IF:	Always
		DO:	ChatExpr {`/ub fellow create `+@CCFellowname}

	~~ If fellow is created move to FellowInvite
	IF:	Expr {getfellowshipstatus[]==1}
		DO:	SetState {FellowInvite}

	~~ If fellow isn't created try again
	IF:	SecsInStateGE 1
		DO:	SetState {FellowCreate}

~~ }


STATE: {FellowInvite} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Create blacklist
	IF: Expr {testvar[FellowBlacklist]==false}
		DO: DoExpr {$FellowBlacklist=listcreate[]}

	~~ Find all nearby players who are in @CCCharacterList
	IF: Always
		DO: DoAll
				DoExpr {$AllNearbyPlayers=listmap[wobjectfindallbyobjectclass[$PLAYER],`wobjectgetstringprop[$1,1]`]}
				DoExpr {$AllNearbyCharacterList=listfilter[$AllNearbyPlayers, `listcontains[@CCCharacterList, $1]`]}
				DoExpr {$AllNearbyNotInFellow=listfilter[$AllNearbyCharacterList, `listcontains[getfellownames[], $1]==false`]}
				DoExpr {$AllNearbyNotInFellowNotBlacklisted=listfilter[$AllNearbyNotInFellow, `listcontains[$FellowBlacklist, $1]==false`]}

	~~ Clear variables and return to idle if there are no more players to add
	IF: Expr {listcount[$AllNearbyNotInFellowNotBlacklisted]==0}
		DO: DoAll
				DoExpr {listmap[listcreate[`AllNearbyPlayers`, `AllNearbyCharacterList`, `AllNearbyNotInFellow`, `AllNearbyNotInFellowNotBlacklisted`, `FellowBlacklist`, `name`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Recruit a nearby player in $CCCharacterlist
	IF: Always
		DO: DoAll
				DoExpr {$name=listpop[$AllNearbyNotInFellowNotBlacklisted, 0]}
				ChatExpr {`/ub fellow recruit `+$name}
				SetState {FellowInvite}
	
	~~ Blacklist the character if already in a fellow
	IF: Any
			ChatMatch {is already a member of a Fellowship.$}
			ChatMatch {is not accepting fellowship requests.$}
		DO: DoAll
				DoExpr {listadd[$FellowBlacklist, $name]}
				SetState {FellowInvite}

~~ }


STATE: {FellowNearby} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Abort if not in a fellow
	IF: Expr {getfellowshipstatus[]==false}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] Aborting, not in a fellow\`, $COLOR_WARN]`, `false`]}
				SetState {Idle}

	~~ Create blacklist
	IF: Expr {testvar[FellowBlacklist]==false}
		DO: DoExpr {$FellowBlacklist=listcreate[]}

	~~ Find all nearby characters
	IF: Always
		DO: DoAll
				DoExpr {$AllNearbyPlayers=listmap[wobjectfindallbyobjectclass[$PLAYER], `wobjectgetstringprop[$1, 1]`]}
				DoExpr {$AllNearbyExceptSelf=listfilter[$AllNearbyPlayers, `$1!=$CHARACTER_NAME`]}
				DoExpr {$AllNearbyPlayersWithinRange=listfilter[$AllNearbyExceptSelf, `coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$PLAYER, $1]], getplayercoordinates[]]<@CCFellowNearbyRecruitDistance`]}
				DoExpr {$AllNearbyNotInFellow=listfilter[$AllNearbyPlayersWithinRange, `listcontains[getfellownames[], $1]==false`]}
				DoExpr {$AllNearbyNotInFellowNotBlacklisted=listfilter[$AllNearbyNotInFellow, `listcontains[$FellowBlacklist, $1]==false`]}

			~~ Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$NPC, `Viridian Portal`]],getplayercoordinates[]]<$CLOSE_BLUE}

	~~ Clear variables and return to idle if there are no more characters to add
	IF: Any
			Expr {listcount[$AllNearbyNotInFellowNotBlacklisted]==0}
			Expr {getfellowshipcount[]>=@CCMaxFellowshipSize}
		DO: DoAll
				DoExpr {listmap[listcreate[`AllNearbyPlayers`, `AllNearbyExceptSelf`, `AllNearbyPlayersWithinRange`, `AllNearbyNotInFellow`, `AllNearbyNotInFellowNotBlacklisted`, `FellowBlacklist`, `name`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Recruit a nearby character
	IF: Always
		DO: DoAll
				DoExpr {$name=listpop[$AllNearbyNotInFellowNotBlacklisted, 0]}
				ChatExpr {`/ub fellow recruit `+$name}
				SetState {FellowNearby}

	~~ Blacklist the character if already in a fellow
	IF: Any
			ChatMatch {is already a member of a Fellowship.$}
			ChatMatch {is not accepting fellowship requests.$}
		DO: DoAll
				DoExpr {listadd[$FellowBlacklist, $name]}
				SetState {FellowNearby}

~~}


STATE: {FellowAdd} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Always
		DO: DoExpr {$namerx=$capturegroup_namerx}

	~~ Abort if not in a fellow
	IF: Expr {getfellowshipstatus[]==false}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] Aborting, not in a fellow\`, $COLOR_WARN]`, `false`]}
				SetState {Idle}

	~~ Warn if no players are found
	IF: Expr {listcount[listfilter[wobjectfindallbynamerx[$namerx], `wobjectgetobjectclass[$1]==$PLAYER`]]==0}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] No players found!\`, $COLOR_WARN]`, `false`]}
				SetState {Idle}

	~~ Create blacklist
	IF: Expr {testvar[FellowBlacklist]==false}
		DO: DoExpr {$FellowBlacklist=listcreate[]}

	~~ Find all characters with $namerx
	IF: Always
		DO: DoAll
				DoExpr {$AllCharacters=listfilter[wobjectfindallbynamerx[$namerx], `wobjectgetobjectclass[$1]==$PLAYER`]}
				DoExpr {$AllCharacterNames=listmap[$AllCharacters, `wobjectgetstringprop[$1, 1]`]}
				DoExpr {$AllCharactersNotInFellow=listfilter[$AllCharacterNames, `listcontains[getfellownames[], $1]==false`]}
				DoExpr {$AllCharactersNotInFellowNotBlacklisted=listfilter[$AllCharactersNotInFellow, `listcontains[$FellowBlacklist, $1]==false`]}

	~~ Clear variables and return to idle if there are no more characters to add
	IF: Any
			Expr {listcount[$AllCharactersNotInFellowNotBlacklisted]==0}
			Expr {getfellowshipcount[]>=@CCMaxFellowshipSize}
		DO: DoAll
				DoExpr {listmap[listcreate[`AllCharacters`, `AllCharacterNames`, `AllCharactersNotInFellow`, `AllCharactersNotInFellowNotBlacklisted`, `FellowBlacklist`, `name`, `namerx`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Recruit a character
	IF: Always
		DO: DoAll
				DoExpr {$name=listpop[$AllCharactersNotInFellowNotBlacklisted, 0]}
				DoExpr {ifthen[$LEVEL_DEBUG>=@CCDebug, `echo[\`[WARN] recruiting \`+$name, $COLOR_DEBUG]`, `false`]}
				ChatExpr {`/ub fellow recruit `+$name}
				SetState {FellowAdd}

	~~ Blacklist the character if already in a fellow
	IF: Any
			ChatMatch {is already a member of a Fellowship.$}
			ChatMatch {is not accepting fellowship requests.$}
		DO: DoAll
				DoExpr {listadd[$FellowBlacklist, $name]}
				SetState {FellowAdd}

~~ }


STATE: {HandleRecall} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Return to Idle if the spell isn't known
	IF: Not Expr {getisspellknown[$CCRecallSpell]}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I do not know this recall spell\`]`, `false`]}
				SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {HandleRecall}

	~~ Close recalls view
	IF: Expr {uiviewvisible[Recalls]}
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto >>`]}
				DestroyView {Recalls}

	~~ Cast the recall spell
	IF: Expr {isportaling[]==false}
		DO: DoAll
				DoExpr {actiontrycastbyid[$CCRecallSpell]}
				SetState {HandleRecall}

	~~ Finished recalling; go to LeaderCheck
	IF: Expr {isportaling[]==true}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished recalling\`]`, `false`]}
				SetState {LeaderCheck}

~~}


STATE: {UseNPC} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UseNPC}

	~~ If set equip item to talk to npc
	IF: All
			Expr {@CCEquipOnTurnin!=false} 
			Expr {wobjectfindnearestbyobjectclass[31]!=@CCEquipOnTurnin}
			Expr {testvar[equipped]==false}
		DO: DoAll
				DoExpr {actiontryuseitem[@CCEquipOnTurnin]}
				DoExpr {$equipped=true}

	~~ Stop using NPC if you receieve a response
	IF:	Any
			All
				ChatCapture {^(?<tellname>.*?) tells you, \"(?<npctext>.*)\"$} {}
				Expr {$capturegroup_tellname==$name}
			All
				ChatCapture {^(?<tellname>.*?) gives you (?<npctext>.*)$} {}
				Expr {$capturegroup_tellname==$name}
			All
				ChatCapture {^(?<tellname>.*?) cast (?<npctext>.*)$} {}
				Expr {$capturegroup_tellname==$name}
			ChatMatch {^You've earned}
			ChatMatch {^You may complete this quest}
			ChatMatch {^A plaque on}
			ChatMatch {^You have already gained}
			ChatMatch {^You shock yourself}
			ChatMatch {^As you touch}
			ChatMatch {^A voice in your mind}
			ChatMatch {^According to the plaque}
			ChatMatch {^You search through the parts}
			ChatMatch {^You must wait}
			ChatMatch {^The stone eyes widens}
			ChatMatch {^Looking at the tusker corpse} ~~ Slain Protectorate
			ChatMatch {^You have killed} ~~ Slain Protectorate
			IntoPortal
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Talked to \`+$name]`, `false`]}
				DoExpr {clearvar[equipped]}
				SetState {LeaderCheck}

	~~ Use NPC
	IF: Always
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$NPC]]}
				DoExpr {$name=wobjectgetstringprop[wobjectfindnearestbyobjectclass[$NPC], $STRING_PROP_NAME]}
				SetState {UseNPC}

~~ }


STATE: {UseVendor} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UseVendor}
	
	~~ Autovendor finished
	IF:	ChatMatch {^You think, "AutoVendor finished}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished vending with \`+$name]`, `false`]}
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$VENDOR]]} ~~ Close the vendor window
				DoExpr {clearvar[open]}
				SetState {LeaderCheck}

	~~ Use Vendor
	IF: VendorClosed 
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$VENDOR]]}
				DoExpr {$name=wobjectgetstringprop[wobjectfindnearestbyobjectclass[$VENDOR], $STRING_PROP_NAME]}
				SetState {UseVendor}

~~ }


STATE: {ReadContracts} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {$CCReset=true}
				SetState {Finished}

	~~ If Remaining contracts try using them
	IF: Expr {getitemcountininventorybynamerx[`(Hunting\: Lost City of Neftet)|(Contract for)`]>0}
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindininventorybynamerx[`(Hunting\: Lost City of Neftet)|(Contract for)`]]}
				SetState {ReadContracts}

	~~ No contracts left return to Idle
	IF: Expr {getitemcountininventorybynamerx[`(Hunting\: Lost City of Neftet)|(Contract for)`]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished reading contracts\`]`, `false`]}
				SetState {Idle}

~~ }


STATE: {DisableOptions} ~~ {

	~~ Store original options so we can reset them
	IF: Always
		DO: DoAll
				DoExpr {setvar[OriginalEnableNav, vtgetsetting[EnableNav]]}
				DoExpr {setvar[OriginalEnableCombat, vtgetsetting[EnableCombat]]}
				DoExpr {setvar[OriginalEnableBuffing, vtgetsetting[EnableBuffing]]}
				DoExpr {setvar[OriginalEnableLooting, vtgetsetting[EnableLooting]]}
				DoExpr {setvar[OptionsSet, true]}

	~~ Disable all options
	IF:	Always
		DO:	DoAll
				SetOpt {EnableNav} {False}
				SetOpt {EnableCombat} {False}
				SetOpt {EnableBuffing} {False}
				SetOpt {EnableLooting} {False}

	~~ Return
	IF: Always
		DO: Return

~~ }


STATE: {EnableOptions} ~~ {

	~~ Enable options
	IF:	Always
		DO:	DoAll
				SetOpt {EnableNav} {$OriginalEnableNav}
				SetOpt {EnableCombat} {$OriginalEnableCombat}
				SetOpt {EnableBuffing} {$OriginalEnableBuffing}
				SetOpt {EnableLooting} {$OriginalEnableLooting}

	~~ Clear all vars
	IF: Always
		DO: DoAll
				DoExpr {clearvar[OriginalEnableNav]}
				DoExpr {clearvar[OriginalEnableCombat]}
				DoExpr {clearvar[OriginalEnableBuffing]}
				DoExpr {clearvar[OriginalEnableLooting]}
				DoExpr {clearvar[OptionsSet]}

	~~ Return
	IF: Always
		DO: Return

~~ }


STATE: {ShowJump} ~~ {

	~~ Show Jump view
	IF: Not Expr {uiviewvisible[Jump]}
		DO: DoAll
				CreateView {Jump} {:CheCommand-Jump.xml}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowJump], `Jump <<`]}
				SetState {Idle}

	~~ Close Jump view
	IF: Expr {uiviewvisible[Jump]}
		DO: DoAll
				DestroyView {Jump}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowJump], `Jump >>`]}
				SetState {Idle}
~~ }


STATE: {ShowNavto} ~~ {

	~~ Show Navto view
	IF: All
			Not Expr {uiviewvisible[Navto]}
			Not Expr {uiviewvisible[Recalls]}
		DO: DoAll
				CreateView {Navto} {:CheCommand-TownNetwork.xml}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto <<`]}
				SetState {Idle}

	~~ Close Jump view
	IF: Any
			Expr {uiviewvisible[Navto]}
			Expr {uiviewvisible[Recalls]}
		DO: DoAll
				DestroyView {Navto}
				DestroyView {Recalls}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto >>`]}
				SetState {Idle}


~~ }


STATE: {ShowRecalls} ~~ {

	~~ Show Navto view
	IF: Not Expr {uiviewvisible[Recalls]}
		DO: DoAll
				DestroyView {Navto}
				CreateView {Recalls} {:CheCommand-Recalls.xml}
				~~ DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto <<`]}
				SetState {Idle}

	~~ Close Jump view
	IF: Expr {uiviewvisible[Recalls]}
		DO: DoAll
				DestroyView {Recalls}
				~~ DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto >>`]}
				SetState {Idle}


~~ }
STATE: {SetupButtons} ~~ {

	IF: Always
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Main, Follow], ifthen[@CCStay, `Follow`, `Stay`]]}
				~~ DoExpr {uisetlabel[uigetcontrol[Main, Combat], ifthen[testpvar[CCOriginalVitalsEnableCombat], `ifthen[@CCOriginalVitalsEnableCombat, \`Combat Off\`, \`Combat On\`]`, `ifthen[vtgetsetting[EnableCombat], \`Combat Off\`, \`Combat On\`]`]]}

	IF: Always
		DO: SetState {Idle}

~~ }

STATE: {ToggleStay} ~~ {

	IF: Expr {@CCStay==true}
		DO: DoAll
				ChatExpr {`#action follow`}
				DoExpr {uisetlabel[uigetcontrol[Main, Follow], `Stay`]}
				SetState {Idle}

	IF: Expr {@CCStay==false}
		DO: DoAll
				ChatExpr {`#action stay`}
				DoExpr {uisetlabel[uigetcontrol[Main, Follow], `Follow`]}
				SetState {Idle}

~~ }


~~ STATE: {ToggleCombat} ~~ {

~~ 	IF: Expr {ifthen[testpvar[CCOriginalVitalsEnableCombat], `@CCOriginalVitalsEnableCombat`, `vtgetsetting[EnableCombat]`]==true}
~~ 		DO: DoAll
~~ 				ChatExpr {`#vtoption enablecombat false`}
~~ 				DoExpr {uisetlabel[uigetcontrol[Main, Combat], `Combat On`]}
~~ 				SetState {Idle}

~~ 	IF: Expr {ifthen[testpvar[CCOriginalVitalsEnableCombat], `@CCOriginalVitalsEnableCombat`, `vtgetsetting[EnableCombat]`]==false}
~~ 		DO: DoAll
~~ 				ChatExpr {`#vtoption enablecombat true`}
~~ 				DoExpr {uisetlabel[uigetcontrol[Main, Combat], `Combat Off`]}
~~ 				SetState {Idle}

~~ ~~ }


~~ Use Virindi Hotkey System to map this state to a key like `tab` to toggle on and off combat/healing/buffing
STATE: {HotkeyToggleVitals} ~~ {
	IF: Expr {@CCVitals==true}
		DO: DoAll
				DoExpr {@CCVitals=false} ~~ Toggle vitals
				DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Turning off vitals\`, $COLOR_INFO]`, `false`]}
				DoExpr {setpvar[CCOriginalVitalsEnableBuffing, cstr[vtgetsetting[EnableBuffing]]]}
				DoExpr {setpvar[CCOriginalVitalsEnableCombat, cstr[vtgetsetting[EnableCombat]]]}
				DoExpr {setpvar[CCOriginalVitalsEnableLooting, cstr[vtgetsetting[EnableLooting]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNormHitP, cstr[vtgetsetting[Recharge-Norm-HitP]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNormStam, cstr[vtgetsetting[Recharge-Norm-Stam]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNormMana, cstr[vtgetsetting[Recharge-Norm-Mana]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNoTargHitP, cstr[vtgetsetting[Recharge-NoTarg-HitP]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNoTargStam, cstr[vtgetsetting[Recharge-NoTarg-Stam]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNoTargMana, cstr[vtgetsetting[Recharge-NoTarg-Mana]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeHelperHitP, cstr[vtgetsetting[Recharge-Helper-HitP]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeHelperStam, cstr[vtgetsetting[Recharge-Helper-Stam]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeHelperMana, cstr[vtgetsetting[Recharge-Helper-Mana]]]}
				DoExpr {vtsetsetting[EnableBuffing, `0`]}
				DoExpr {vtsetsetting[EnableCombat, `0`]}
				DoExpr {vtsetsetting[EnableLooting, `0`]}
				DoExpr {vtsetsetting[Recharge-Norm-HitP, `0`]}
				DoExpr {vtsetsetting[Recharge-Norm-Stam, `0`]}
				DoExpr {vtsetsetting[Recharge-Norm-Mana, `0`]}
				DoExpr {vtsetsetting[Recharge-NoTarg-HitP, `0`]}
				DoExpr {vtsetsetting[Recharge-NoTarg-Stam, `0`]}
				DoExpr {vtsetsetting[Recharge-NoTarg-Mana, `0`]}
				DoExpr {vtsetsetting[Recharge-Helper-HitP, `0`]}
				DoExpr {vtsetsetting[Recharge-Helper-Stam, `0`]}
				DoExpr {vtsetsetting[Recharge-Helper-Mana, `0`]}
				SetState {Idle}

	IF: Expr {@CCVitals==false}
		DO: DoAll
				DoExpr {@CCVitals=true} ~~ Toggle vitals
				DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Turning on vitals\`, $COLOR_INFO]`, `false`]}
				DoExpr {vtsetsetting[EnableBuffing, @CCOriginalVitalsEnableBuffing]}
				DoExpr {vtsetsetting[EnableCombat, @CCOriginalVitalsEnableCombat]}
				DoExpr {vtsetsetting[EnableLooting, @CCOriginalVitalsEnableLooting]}
				DoExpr {vtsetsetting[Recharge-Norm-HitP, @CCOriginalVitalsRechargeNormHitP]}
				DoExpr {vtsetsetting[Recharge-Norm-Stam, @CCOriginalVitalsRechargeNormStam]}
				DoExpr {vtsetsetting[Recharge-Norm-Mana, @CCOriginalVitalsRechargeNormMana]}
				DoExpr {vtsetsetting[Recharge-NoTarg-HitP, @CCOriginalVitalsRechargeNoTargHitP]}
				DoExpr {vtsetsetting[Recharge-NoTarg-Stam, @CCOriginalVitalsRechargeNoTargStam]}
				DoExpr {vtsetsetting[Recharge-NoTarg-Mana, @CCOriginalVitalsRechargeNoTargMana]}
				DoExpr {vtsetsetting[Recharge-Helper-HitP, @CCOriginalVitalsRechargeHelperHitP]}
				DoExpr {vtsetsetting[Recharge-Helper-Stam, @CCOriginalVitalsRechargeHelperStam]}
				DoExpr {vtsetsetting[Recharge-Helper-Mana, @CCOriginalVitalsRechargeHelperMana]}
				SetState {Idle}

	IF: Always
		DO: SetState {Idle}
~~ }

NAV: Empty once ~~ {
~~